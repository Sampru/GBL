<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>AFU: src/mciFxg.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AFU
   &#160;<span id="projectnumber">4.1</span>
   </div>
   <div id="projectbrief">ALMIS_Financial_utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mci_fxg_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mciFxg.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for specific function in the initial values fixing.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;cardinal.h&gt;</code><br/>
<code>#include &lt;cst_def.h&gt;</code><br/>
<code>#include &lt;db_def.h&gt;</code><br/>
<code>#include &lt;dynDef.h&gt;</code><br/>
<code>#include &lt;errDef.h&gt;</code><br/>
<code>#include &lt;gb.h&gt;</code><br/>
<code>#include &lt;math_def.h&gt;</code><br/>
<code>#include &lt;mb_def.h&gt;</code><br/>
<code>#include &lt;obj_def.h&gt;</code><br/>
<code>#include &lt;tm_def.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="afu__def_8h_source.html">afu_def.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="afu__types_8h_source.html">afu_types.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="afu_joi_def_8h_source.html">afuJoiDef.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="mci__def_8h_source.html">mci_def.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="mkt__def_8h_source.html">mkt_def.h</a>&gt;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1f15293623649a310a7c68ff240f9647"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a1f15293623649a310a7c68ff240f9647">MSG_LEN</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a1f15293623649a310a7c68ff240f9647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1c947ab26831233f25df176e958f72f8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a1c947ab26831233f25df176e958f72f8">lcMCIfxgAplCmpFun</a> (void *LdFxg, int CntFxg, char *Fxd)</td></tr>
<tr class="memdesc:a1c947ab26831233f25df176e958f72f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the configured component function to the subcomponents.  <a href="#a1c947ab26831233f25df176e958f72f8"></a><br/></td></tr>
<tr class="separator:a1c947ab26831233f25df176e958f72f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292fc7de0040e4574296a3568e9c9311"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a292fc7de0040e4574296a3568e9c9311">lcMCIfxgAplCnd</a> (void *LdFxg, int CntFxg)</td></tr>
<tr class="memdesc:a292fc7de0040e4574296a3568e9c9311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the condition function.  <a href="#a292fc7de0040e4574296a3568e9c9311"></a><br/></td></tr>
<tr class="separator:a292fc7de0040e4574296a3568e9c9311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70281efb4a43f645a9dfe7eec1bd19f4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a70281efb4a43f645a9dfe7eec1bd19f4">lcMCIfxgAplCndFcn</a> (void *LdFxg, int CntFxg, void *LdDta)</td></tr>
<tr class="memdesc:a70281efb4a43f645a9dfe7eec1bd19f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the condition function.  <a href="#a70281efb4a43f645a9dfe7eec1bd19f4"></a><br/></td></tr>
<tr class="separator:a70281efb4a43f645a9dfe7eec1bd19f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe01f246ff9f3742af057bab63136335"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#afe01f246ff9f3742af057bab63136335">lcMCIfxgAplSubCmpFun</a> (void *LdDta, int CntDta)</td></tr>
<tr class="memdesc:afe01f246ff9f3742af057bab63136335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the configured component function to market data used in fixing treatment.  <a href="#afe01f246ff9f3742af057bab63136335"></a><br/></td></tr>
<tr class="separator:afe01f246ff9f3742af057bab63136335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ed24eb91e26c6b15e47f4f7956ca8a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#ac7ed24eb91e26c6b15e47f4f7956ca8a">lcMCIfxgCalCmp</a> (void *Ctx, void *LdAls, void *LdFxg, int CntFxg, void *LdMktFxg, void *LdMktCmp)</td></tr>
<tr class="memdesc:ac7ed24eb91e26c6b15e47f4f7956ca8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subcomponents initial values list calculation.  <a href="#ac7ed24eb91e26c6b15e47f4f7956ca8a"></a><br/></td></tr>
<tr class="separator:ac7ed24eb91e26c6b15e47f4f7956ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a03d05511feda0567aeda9375784284"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a9a03d05511feda0567aeda9375784284">lcMCIfxgCalOneLop</a> (void *Ctx, void *LdAls, void *LdFxg, void *LdDat, void *LdMktFxg, void *LdMktCmp, char *Fxd, int AllFxg, int *Oth)</td></tr>
<tr class="memdesc:a9a03d05511feda0567aeda9375784284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the initial values for some conditions.  <a href="#a9a03d05511feda0567aeda9375784284"></a><br/></td></tr>
<tr class="separator:a9a03d05511feda0567aeda9375784284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b8937ca97516d45fab411965206ec2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#aa7b8937ca97516d45fab411965206ec2">lcMCIfxgChkMkt</a> (void *LdFxg, void *LdDat, void *LdMkt, char *Fxd, int Mkt, int AllFxg)</td></tr>
<tr class="memdesc:aa7b8937ca97516d45fab411965206ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the existence of the market data to fix the initial values.  <a href="#aa7b8937ca97516d45fab411965206ec2"></a><br/></td></tr>
<tr class="separator:aa7b8937ca97516d45fab411965206ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399889912cec738aa108e53260c05ed2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a399889912cec738aa108e53260c05ed2">lcMCIfxgChkMktNotOnDat</a> (char *Fxd, void *LdFxg, void *LdDat, void *LdMkt, int AllFxg)</td></tr>
<tr class="memdesc:a399889912cec738aa108e53260c05ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the needed initial values of conditions are already fixed.  <a href="#a399889912cec738aa108e53260c05ed2"></a><br/></td></tr>
<tr class="separator:a399889912cec738aa108e53260c05ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02d19f27f642e3a2a0ee2f7b9a3d595"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#ac02d19f27f642e3a2a0ee2f7b9a3d595">lcMCIfxgCnf</a> (void *Ctx, void *LdDta, char *FxgDat)</td></tr>
<tr class="memdesc:ac02d19f27f642e3a2a0ee2f7b9a3d595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confirm inital values for selected instruments.  <a href="#ac02d19f27f642e3a2a0ee2f7b9a3d595"></a><br/></td></tr>
<tr class="separator:ac02d19f27f642e3a2a0ee2f7b9a3d595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fd191950d493d5837f66549e9ae9e0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a09fd191950d493d5837f66549e9ae9e0">lcMCIfxgFndPvb</a> (void *LdPvb, char *ValFld, char *Als, int Num, char *Fld, void *LdDta, int CntDta, void **DtaOut, short *VldOut)</td></tr>
<tr class="memdesc:a09fd191950d493d5837f66549e9ae9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the value of a string type variable parameter.  <a href="#a09fd191950d493d5837f66549e9ae9e0"></a><br/></td></tr>
<tr class="separator:a09fd191950d493d5837f66549e9ae9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f20aa5cc95de43061c044e009261ed6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a9f20aa5cc95de43061c044e009261ed6">lcMCIfxgFndTdt</a> (void *Ctx, void *LdFxg, int CntFxg, char *TimCol, char *Fxd, void *LdTdt, double *TdtVal, short *VldOut)</td></tr>
<tr class="memdesc:a9f20aa5cc95de43061c044e009261ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value depending on a time dependent table.  <a href="#a9f20aa5cc95de43061c044e009261ed6"></a><br/></td></tr>
<tr class="separator:a9f20aa5cc95de43061c044e009261ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6768c3781acb0077630e6882a61569c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#af6768c3781acb0077630e6882a61569c">lcMCIfxgFxg</a> (void *Ctx, void *LdAls, char *Fxd, char *Pro, int Fix, int AllFxg, void *LdFxg, void **LdOut)</td></tr>
<tr class="memdesc:af6768c3781acb0077630e6882a61569c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix the initial values for some instruments.  <a href="#af6768c3781acb0077630e6882a61569c"></a><br/></td></tr>
<tr class="separator:af6768c3781acb0077630e6882a61569c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc9fedd782ff2c54aa4fad21c4d542d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a3bc9fedd782ff2c54aa4fad21c4d542d">lcMCIfxgFxgMci</a> (void *Ctx, void *LdAls, char *Fxd, char *Pro, int Fix, int AllFxg, void *LdFxg, void *LdMciPvb, void *LdMciTdt, int Pur)</td></tr>
<tr class="memdesc:a3bc9fedd782ff2c54aa4fad21c4d542d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix the initial values for some components.  <a href="#a3bc9fedd782ff2c54aa4fad21c4d542d"></a><br/></td></tr>
<tr class="separator:a3bc9fedd782ff2c54aa4fad21c4d542d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285405835818c5b9e2fef4b83d23ca81"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a285405835818c5b9e2fef4b83d23ca81">lcMCIfxgFulFxgMci</a> (void *Ctx, void *LdAls, char *Fxd, void *LdFxg, void *LdMciPvb, void *LdMciTdt)</td></tr>
<tr class="memdesc:a285405835818c5b9e2fef4b83d23ca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix the initial values for some components.  <a href="#a285405835818c5b9e2fef4b83d23ca81"></a><br/></td></tr>
<tr class="separator:a285405835818c5b9e2fef4b83d23ca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4979da7d13b62d21d64ed4d96f6deb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#aeb4979da7d13b62d21d64ed4d96f6deb">lcMCIfxgGetAllFxgDat</a> (void *Ctx, void *LdAls, void *LdFxg, char *Fxd, int All, void *LdMciTdt, void **LdDat, int *NedFxg)</td></tr>
<tr class="memdesc:aeb4979da7d13b62d21d64ed4d96f6deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets fixing dates.  <a href="#aeb4979da7d13b62d21d64ed4d96f6deb"></a><br/></td></tr>
<tr class="separator:aeb4979da7d13b62d21d64ed4d96f6deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ffb949347b3857b8500c979fabefac"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a46ffb949347b3857b8500c979fabefac">lcMCIfxgGetFxgDat</a> (char *Mci, char *Beg, char *End, char *Dat, char *Frq, char *Shl, char *Adj, char *Pfl, char *Dev, void *LlMciCcy, char *Mdb, char *FxgDat, void *LlTim, char *Tdt, int All)</td></tr>
<tr class="memdesc:a46ffb949347b3857b8500c979fabefac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last fixing date of a condition period.  <a href="#a46ffb949347b3857b8500c979fabefac"></a><br/></td></tr>
<tr class="separator:a46ffb949347b3857b8500c979fabefac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bb0a3e8a251411f3e8a923a425f1e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#aa9bb0a3e8a251411f3e8a923a425f1e9">lcMCIfxgGetFxgLstDat</a> (char *Mci, char *Beg, char *End, char *Dat, char *Frq, char *Shl, char *Adj, char *Pfl, char *Dev, void *LlMciCcy, char *Mdb, int All, void *LLTim, char *Tdt, void **LdDat)</td></tr>
<tr class="memdesc:aa9bb0a3e8a251411f3e8a923a425f1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fixing dates list of a condition period.  <a href="#aa9bb0a3e8a251411f3e8a923a425f1e9"></a><br/></td></tr>
<tr class="separator:aa9bb0a3e8a251411f3e8a923a425f1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7410d3a4d9d72a2f6eeb0db45544437c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a7410d3a4d9d72a2f6eeb0db45544437c">lcMCIfxgGetMci</a> (void *Ctx, void *LdAls, void *LdMciObj, int CntMci, char *Dat, int All, void **LdVal)</td></tr>
<tr class="memdesc:a7410d3a4d9d72a2f6eeb0db45544437c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete with the initial values for a deal in a given date.  <a href="#a7410d3a4d9d72a2f6eeb0db45544437c"></a><br/></td></tr>
<tr class="separator:a7410d3a4d9d72a2f6eeb0db45544437c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d044fa3c4f9e535101edddc8a1109b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a48d044fa3c4f9e535101edddc8a1109b">lcMCIfxgGetMkt</a> (void *Ctx, char *Pro, void *LdUmc, void *LdDat, char *Fxd, int Off, void **LdAll)</td></tr>
<tr class="memdesc:a48d044fa3c4f9e535101edddc8a1109b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get market data value for the treated UMC and for the treated dates.  <a href="#a48d044fa3c4f9e535101edddc8a1109b"></a><br/></td></tr>
<tr class="separator:a48d044fa3c4f9e535101edddc8a1109b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b1d0a6b6f775bbc2001923c5c91d8a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a36b1d0a6b6f775bbc2001923c5c91d8a">lcMCIfxgGetMktCmp</a> (void *Ctx, void *LdAls, void *LdFxg, void *LdDat, char *Fxd, void **LdAll)</td></tr>
<tr class="memdesc:a36b1d0a6b6f775bbc2001923c5c91d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get market data value for the treated UMC and for the treated dates.  <a href="#a36b1d0a6b6f775bbc2001923c5c91d8a"></a><br/></td></tr>
<tr class="separator:a36b1d0a6b6f775bbc2001923c5c91d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9633cab20c6e63b74cdadc444493f96b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a9633cab20c6e63b74cdadc444493f96b">lcMCIfxgGetUmcMkt</a> (void *LdMkt, void *LdFxg, int CntFxg, int Mkt, void **LdMktUmc)</td></tr>
<tr class="memdesc:a9633cab20c6e63b74cdadc444493f96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get market data lines for the treated condition.  <a href="#a9633cab20c6e63b74cdadc444493f96b"></a><br/></td></tr>
<tr class="separator:a9633cab20c6e63b74cdadc444493f96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d0c364e4eaae7cfce490816ff022d0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#af5d0c364e4eaae7cfce490816ff022d0">lcMCIfxgIniVec</a> (void *LdFxg)</td></tr>
<tr class="memdesc:af5d0c364e4eaae7cfce490816ff022d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the fixing data list taking into account vectors.  <a href="#af5d0c364e4eaae7cfce490816ff022d0"></a><br/></td></tr>
<tr class="separator:af5d0c364e4eaae7cfce490816ff022d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513eb7e20a4a5a5e3314b259067e52a0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a513eb7e20a4a5a5e3314b259067e52a0">lcMCIfxgIsCal</a> (void *LdFxg, int CntFxg, int *ToFix)</td></tr>
<tr class="memdesc:a513eb7e20a4a5a5e3314b259067e52a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if a component is calculable or not.  <a href="#a513eb7e20a4a5a5e3314b259067e52a0"></a><br/></td></tr>
<tr class="separator:a513eb7e20a4a5a5e3314b259067e52a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddafbae63e6da8613aa5eec1b58b847"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a2ddafbae63e6da8613aa5eec1b58b847">lcMCIfxgIsToCal</a> (void *LdFxg, int *IsToCal)</td></tr>
<tr class="memdesc:a2ddafbae63e6da8613aa5eec1b58b847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if there is any condition to fix.  <a href="#a2ddafbae63e6da8613aa5eec1b58b847"></a><br/></td></tr>
<tr class="separator:a2ddafbae63e6da8613aa5eec1b58b847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6f9376d9179dc1564b516d0762d02d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#acc6f9376d9179dc1564b516d0762d02d">lcMCIfxgMrkKnwSbc</a> (void *LdFxg, int CntFxg)</td></tr>
<tr class="memdesc:acc6f9376d9179dc1564b516d0762d02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark as known all components that have it as subcomponent.  <a href="#acc6f9376d9179dc1564b516d0762d02d"></a><br/></td></tr>
<tr class="separator:acc6f9376d9179dc1564b516d0762d02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4432fca465540e66ec192c0aa4f31aeb"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a4432fca465540e66ec192c0aa4f31aeb">lcMCIfxgPur</a> (void *Ctx, void *LdFxg, char *Fxd, int Pur)</td></tr>
<tr class="memdesc:a4432fca465540e66ec192c0aa4f31aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge of the incorrect fixed initial values.  <a href="#a4432fca465540e66ec192c0aa4f31aeb"></a><br/></td></tr>
<tr class="separator:a4432fca465540e66ec192c0aa4f31aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7553f3b447c4aeb90f9cac9ff732e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#aff7553f3b447c4aeb90f9cac9ff732e9">lcMCIfxgSetAmoWeiStk</a> (void *Ctx, void *LdAls, void *LdDta, void *LdMciPvb, void *LdMciTdt, char *Fxd)</td></tr>
<tr class="memdesc:aff7553f3b447c4aeb90f9cac9ff732e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amount, weight and strike values for each component.  <a href="#aff7553f3b447c4aeb90f9cac9ff732e9"></a><br/></td></tr>
<tr class="separator:aff7553f3b447c4aeb90f9cac9ff732e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7cfca5870fc285cc5fbc855feba33f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#adb7cfca5870fc285cc5fbc855feba33f">lcMCIfxgSetCndAsRes</a> (void *LdFxg, int CntFxg)</td></tr>
<tr class="memdesc:adb7cfca5870fc285cc5fbc855feba33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the calculated value for a condition in the result list.  <a href="#adb7cfca5870fc285cc5fbc855feba33f"></a><br/></td></tr>
<tr class="separator:adb7cfca5870fc285cc5fbc855feba33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a017ce8fe2bb580ca0141c412d6d70"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#aa0a017ce8fe2bb580ca0141c412d6d70">lcMCIfxgSetCndDat</a> (void *Ctx, void *LdMciPvb, void **LdRes, void *LdAls)</td></tr>
<tr class="memdesc:aa0a017ce8fe2bb580ca0141c412d6d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains and adds to the list the begin/end condition dates.  <a href="#aa0a017ce8fe2bb580ca0141c412d6d70"></a><br/></td></tr>
<tr class="separator:aa0a017ce8fe2bb580ca0141c412d6d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4813b05f742d3c81324eb43e93847ac4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a4813b05f742d3c81324eb43e93847ac4">lcMCIfxgSetEquPof</a> (void *LdFxg)</td></tr>
<tr class="memdesc:a4813b05f742d3c81324eb43e93847ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert equivalent payoff functions. E.g.: stop -&gt; if.  <a href="#a4813b05f742d3c81324eb43e93847ac4"></a><br/></td></tr>
<tr class="separator:a4813b05f742d3c81324eb43e93847ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb48fd7d85aa0fb48602a561b95542f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a6fb48fd7d85aa0fb48602a561b95542f">lcMCIfxgSetSbcToCal</a> (void *LdFxg, int CntFxg)</td></tr>
<tr class="memdesc:a6fb48fd7d85aa0fb48602a561b95542f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark component and all its subcomponents that will be calculated.  <a href="#a6fb48fd7d85aa0fb48602a561b95542f"></a><br/></td></tr>
<tr class="separator:a6fb48fd7d85aa0fb48602a561b95542f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577385bb358fb18c79263a2b02a1e0a8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a577385bb358fb18c79263a2b02a1e0a8">lcMCIfxgSetToCal</a> (void *LdFxg)</td></tr>
<tr class="memdesc:a577385bb358fb18c79263a2b02a1e0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the components that will be calculated.  <a href="#a577385bb358fb18c79263a2b02a1e0a8"></a><br/></td></tr>
<tr class="separator:a577385bb358fb18c79263a2b02a1e0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba7b43fb5b082eb2785108705be4f35"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a2ba7b43fb5b082eb2785108705be4f35">lcMCIfxgSetPvbCmpTyp</a> (void *LdPvb, void *LdDta)</td></tr>
<tr class="memdesc:a2ba7b43fb5b082eb2785108705be4f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the variable parameter for the component type.  <a href="#a2ba7b43fb5b082eb2785108705be4f35"></a><br/></td></tr>
<tr class="separator:a2ba7b43fb5b082eb2785108705be4f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4504e95a8405826dd7fdfc314812cd23"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a4504e95a8405826dd7fdfc314812cd23">lcMCIfxgSolTpr</a> (void *Ctx, void *LdAls, void *LdFxg, char *Fxd)</td></tr>
<tr class="memdesc:a4504e95a8405826dd7fdfc314812cd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the 'tprior' function.  <a href="#a4504e95a8405826dd7fdfc314812cd23"></a><br/></td></tr>
<tr class="separator:a4504e95a8405826dd7fdfc314812cd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d0369a199f612dda3b93224898d086"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a99d0369a199f612dda3b93224898d086">lcMCIfxgTypIsFxg</a> (char *Typ, int *Fix)</td></tr>
<tr class="memdesc:a99d0369a199f612dda3b93224898d086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a payoff condition type should be fixed or not.  <a href="#a99d0369a199f612dda3b93224898d086"></a><br/></td></tr>
<tr class="separator:a99d0369a199f612dda3b93224898d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bc45dbebe970df645ce8a529290bf9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#af6bc45dbebe970df645ce8a529290bf9">lcMCIfxgVecHasDifFxd</a> (void *LdFxg, int CntFxg, int *DifFxd)</td></tr>
<tr class="memdesc:af6bc45dbebe970df645ce8a529290bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if there is any vector element with different fixing date.  <a href="#af6bc45dbebe970df645ce8a529290bf9"></a><br/></td></tr>
<tr class="separator:af6bc45dbebe970df645ce8a529290bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada99b15a7384c52b9c8f03aed70d5409"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#ada99b15a7384c52b9c8f03aed70d5409">MCIfxgDat</a> (void *Ctx, void *LdMciObj, int CalFxg, int CntMci, char *Dat, void **LdVal)</td></tr>
<tr class="memdesc:ada99b15a7384c52b9c8f03aed70d5409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the initial values for a deal in a given date.  <a href="#ada99b15a7384c52b9c8f03aed70d5409"></a><br/></td></tr>
<tr class="separator:ada99b15a7384c52b9c8f03aed70d5409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d78e66045e4adf87c85452b4a870636"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a7d78e66045e4adf87c85452b4a870636">MCIfxgGetLstDat</a> (char *Mci, char *DatIni, char *DatFin, char *Dat, char *Frq, char *Shl, char *Adj, char *AdjSco, char *AdjMth, char *Ccy, void *LlMciCcy, char *Mdb, int AddDat, int All, void *LLTim, char *Tdt, void **LdVal)</td></tr>
<tr class="memdesc:a7d78e66045e4adf87c85452b4a870636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the list of dates to be fixed between 2 dates, previous or equal to another one.  <a href="#a7d78e66045e4adf87c85452b4a870636"></a><br/></td></tr>
<tr class="separator:a7d78e66045e4adf87c85452b4a870636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f81526de1d59ca5bf97b5b770201a7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a7f81526de1d59ca5bf97b5b770201a7a">MCIfxgChkVal</a> (void *LdMci)</td></tr>
<tr class="memdesc:a7f81526de1d59ca5bf97b5b770201a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the operation is fixed for a date.  <a href="#a7f81526de1d59ca5bf97b5b770201a7a"></a><br/></td></tr>
<tr class="separator:a7f81526de1d59ca5bf97b5b770201a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2852385bfd62049c4cc5115484a7cb1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a2852385bfd62049c4cc5115484a7cb1d">MCIfxgRea</a> (void *Ctx, void *LdAls, int Fix, int AllFxg, char *FxgDat, char *Pro, void *LdMci, void *LdDev, void **LdRes)</td></tr>
<tr class="memdesc:a2852385bfd62049c4cc5115484a7cb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read inital values for selected instruments.  <a href="#a2852385bfd62049c4cc5115484a7cb1d"></a><br/></td></tr>
<tr class="separator:a2852385bfd62049c4cc5115484a7cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604c3348eacac8e84708bf0db2e23319"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a604c3348eacac8e84708bf0db2e23319">MCIfxgCnf</a> (void *Ctx, void *LdDta, char *FxgDat)</td></tr>
<tr class="memdesc:a604c3348eacac8e84708bf0db2e23319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confirm inital values for selected instruments.  <a href="#a604c3348eacac8e84708bf0db2e23319"></a><br/></td></tr>
<tr class="separator:a604c3348eacac8e84708bf0db2e23319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219e550a027e8e281d486d579694356d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a219e550a027e8e281d486d579694356d">MCIfxgExeFxg</a> (void *Ctx, char *Dat, char *Pro)</td></tr>
<tr class="memdesc:a219e550a027e8e281d486d579694356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the fixing of the components of MC instruments.  <a href="#a219e550a027e8e281d486d579694356d"></a><br/></td></tr>
<tr class="separator:a219e550a027e8e281d486d579694356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4768e1a5b65f51a874716bf134a9c39f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a4768e1a5b65f51a874716bf134a9c39f">MCIfxgSetFxgDat</a> (void *Ctx, void *LdAls, void *LdMci, char *Dat, int All)</td></tr>
<tr class="memdesc:a4768e1a5b65f51a874716bf134a9c39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a column with the last fixing date.  <a href="#a4768e1a5b65f51a874716bf134a9c39f"></a><br/></td></tr>
<tr class="separator:a4768e1a5b65f51a874716bf134a9c39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52eceba501c7a6105fc58ce7efb1d87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#ae52eceba501c7a6105fc58ce7efb1d87">MCIfxgPurDea</a> (void *Ctx, char *Dea)</td></tr>
<tr class="memdesc:ae52eceba501c7a6105fc58ce7efb1d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge the fixed initial values for inexistent deals.  <a href="#ae52eceba501c7a6105fc58ce7efb1d87"></a><br/></td></tr>
<tr class="separator:ae52eceba501c7a6105fc58ce7efb1d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e22e69029c11af765c56d0598a4dac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#a29e22e69029c11af765c56d0598a4dac">MCIfxgGetFulMci</a> (void *Ctx, void *LdMciObj, int CntMci, char *Dat, void **LdVal)</td></tr>
<tr class="memdesc:a29e22e69029c11af765c56d0598a4dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all data of a MC instrument.  <a href="#a29e22e69029c11af765c56d0598a4dac"></a><br/></td></tr>
<tr class="separator:a29e22e69029c11af765c56d0598a4dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6cfa4f775740456c713e84259858b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mci_fxg_8c.html#acb6cfa4f775740456c713e84259858b6">MCIfxgGetFxgNpaDat</a> (void *Ctx, void *LdNpa, char *FldNpa, char *Dat, void **LdFxg)</td></tr>
<tr class="memdesc:acb6cfa4f775740456c713e84259858b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refresh function for blind options exercise/expiration: Cash.  <a href="#acb6cfa4f775740456c713e84259858b6"></a><br/></td></tr>
<tr class="separator:acb6cfa4f775740456c713e84259858b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for specific function in the initial values fixing. </p>
<dl class="section user"><dt>Header file</dt><dd><a class="el" href="mci__def_8h.html" title="MCI (Internal function for MonteCarlo simulation module)">mci_def.h</a></dd></dl>
<dl class="section user"><dt>Acronyme</dt><dd>MCIfxg</dd></dl>
<p>This file contains the function that handles this parameters. There are two functions to launch the fixing:</p>
<ul>
<li>MCIfxgDat. Fixing for a deal. Called from the pricer of the deal entry and the prices calculation for market data.</li>
<li>MCIfxgRea. Fix the initial values related to some intruments in a given date</li>
</ul>
<p>Some notes about the fixing treatment:</p>
<ul>
<li>It is calculated for each instrument.</li>
<li>For vectors, each component is called as 'Ele&lt;Nb&gt;', where &lt;Nb&gt; is a correlative number for the components.</li>
<li>The calculations are done in the same order as is defined by the user. Is he the responsible of the coherence of the payoff definition.</li>
<li>The fixing is based in to calculate in each moment all subcomponents that is possible</li>
<li>The fixing of a vector is similar to the fixing of each components as they were independents.</li>
<li>Used dates: -+ Conditions: dates defined for each condition -+ No conditions: fixing date</li>
<li>Usually, the function defined for the components is applied to each subcomponent and these results are summed. There are exceptions as PROD..., see the FEA doc.</li>
<li>If FEA calculations, only the last initial value is used. This means that the last initial value will contain the previously fixed ones.</li>
<li>If any of the asset of a component is in a different currency, if any date is closed, both dates are taken to calculate the initial value for it. This is done because the good one will be that of the following one (supposing following adjustment) and for the calculations, the greater one is taken.</li>
</ul>
<p>Basic algorithm: 1.- Apply to each subcomponent the function taking into account the amount, weight and strike. Also to the components that are already fixed. 2.- Apply the component function taking into account all its subcomponents. Only for components that are not vectors. Once it is calculated, it should be set in 'LdRes'. 3.- Apply the condition function to the data set in 'LdRes'. When this function is applied, it is applied to all previously fixed conditions and the calculated for the current fixing date. To do it, in 'LdRes', we have the previous fixed conditions.</p>
<p>The fixing list has the following columns: </p>
<h2>LdFxg:</h2>
<ul>
<li>TcNum : Ticket number</li>
<li>TcNpa : Deal code</li>
<li>Dva : Value date of the deal</li>
<li>Clo : Maturity date of the deal</li>
<li>MciCod: Instrument code</li>
<li>CmpCod: Component code</li>
<li>CmpNum: Number of subcomponents of the component</li>
<li>CmpNum: Number of subcomponents of the component</li>
<li>CmpVec: Is vector or not</li>
<li>CmpTyp: Component type. Function to apply to the subcomponent</li>
<li>MciParCmpTyp: Value taken from the variable parameters of the deal if a component type is defined as a parameter</li>
<li>Mdb : Flag indicating if when calculating open fixing dates, all the currencies of the instrument must be used or only the correspondent one</li>
<li>Umc : User market code. Only for the assets</li>
<li>AssCod: Asset code. Only for the assets</li>
<li>Dev : Currency of the asset. Only for the assets</li>
<li>TypAmo: Amount type (cte, par, tim, val)</li>
<li>TypWei: Weight type (cte, par, tim, val)</li>
<li>TypStk: Strike type (cte, par, tim, val)</li>
<li>AmoVal: Amount float value</li>
<li>AmoTim: Amount time dependent table</li>
<li>AmoPvb: Amount parameter</li>
<li>WeiVal: Weight value</li>
<li>WeiTim: Weight time dependent table</li>
<li>StkVal: Strike float value</li>
<li>StkTim: Strike time dependent table</li>
<li>StkPvb: Strike parameter</li>
<li>SubTyp: Subcomponent type. Asset (ass) or Component (cmp)</li>
<li>SubCmp: Subcomponent code</li>
<li>SubOrd: Subcomponent order. Used to maintain the order of the schedule as it is.</li>
<li>als : Alias code</li>
<li>bok : Book name</li>
<li>CndCod: Condition code</li>
<li>CndTyp: Condition type: avg, max, min, sum...</li>
<li>CndFrq: Period frequency</li>
<li>FldCndBeg: Field that defines the beginning of the period. Used to know the begin date</li>
<li>FldCndEnd: Field that defines the end of the period. Used to know the end date</li>
<li>Shl : Broken period (short or long)</li>
<li>Adj : If the end of the period should be adjusted (See Pfl)</li>
<li>Pfl : Type of adjust for the end of the period (See Adj)</li>
<li>CndBeg: Begin date of the period</li>
<li>CndEnd: End date of the period</li>
<li>AssCmp: Code of the asset/component. To have in one column the asset code and the component code</li>
<li>FxgDat: Fixing date</li>
<li>New : Calculated inital value</li>
<li>VecEle: Code of the vector element. They are unknow. Created here by code: Ele1, Ele2...</li>
<li>Val : Already fixed value of the initial value</li>
<li>LdFxd : List with the fixing dates of the condition smaller than the current calculation date. For components, only the last fixing date is maintained; the rest are removed because they are not needed.</li>
<li>LdPurFxd : List with all the fixing dates of the condition smaller than the current calculation date. Used to purge the existent fixed initial values.</li>
<li>LdRes : List with the result of the component function. It contains the data to which the condition function is applied.</li>
<li>LdFunDta: List with data of the assets of the component in the period dates list</li>
<li>Knw : To know if the condition is fixed or not in the calculations</li>
<li>ToCal : To know if the condition can be fixed. Constants and components with conditions.</li>
<li>ToFix : To know if the condition can be fixed in a loop</li>
<li>OnDat : 1 to indicate that the condition will be fixed on calculation date</li>
<li>AllFxgDat: Column that appears only if all fixing dates are asked. It will have a list with all the fixing dates</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Ismael SERRANO - 03/Jul/2007 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a1f15293623649a310a7c68ff240f9647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_LEN&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1c947ab26831233f25df176e958f72f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgAplCmpFun </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the configured component function to the subcomponents. </p>
<p>Apply the configured component function to all the subcomponents defined for it and save the calculated data list into the "LdRes" column. The functions implemented by the moment are: "call", "const", "dig", "if", "max", "min", "prod", "tprior", "put", "range", "rank", "return", "round", "sum", "vec". If the component has a subcomponent that is a component, it copies the calculated results for it to 'LdFunDta' to use it into the calculations (the amount, weight and strike are applied).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Data list </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of the treated component </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 23/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 28/Nov/2007: Control function before treat it</li>
<li>Jon BARRUTIA - 30/Nov/2007: Warning messages instead of info</li>
<li>Jon BARRUTIA - 03/Dec/2007: MCI_PAY_OFF_CMP_TYP_VEC treated</li>
<li>Jon BARRUTIA - 17/Dec/2007: MCI_PAY_OFF_CMP_TYP_CTE treated. It does nothing but no warning message is show.</li>
<li>Jon BARRUTIA - 09/Jan/2008: Apply function to each subcomponent data (amount, weight and strike). Added the fixing date as parameter. Set the calculated component code into the list set into LdRes.</li>
<li>Jon BARRUTIA - 23/Jan/2008: Correct bucle</li>
<li>Jon BARRUTIA - 24/Jan/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_IF</li>
<li>Jon BARRUTIA - 31/Jan/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_PRD,MCI_PAY_OFF_CMP_TYP_CAL and MCI_PAY_OFF_CMP_TYP_PUT</li>
<li>Jon BARRUTIA - 04/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_PRT</li>
<li>Jon BARRUTIA - 07/Feb/2008: Init CalVal when Exs=0 to treat cases of only one subcomponent</li>
<li>Jon BARRUTIA - 13/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_RND</li>
<li>Jon BARRUTIA - 13/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_RET</li>
<li>Jon BARRUTIA - 20/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_RNK</li>
<li>Jon BARRUTIA - 29/Feb/2008: After calculating the results, add 'NbFxd' column to it to maintain compatibility with the previous fixed values list.</li>
<li>Jon BARRUTIA - 04/Mar/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_VRN. MCI_PAY_OFF_CMP_TYP_RET corrected</li>
<li>Jon BARRUTIA - 31/Mar/2008: Treat constants with multiples elements as vectors</li>
</ul>
<dl class="section user"><dt>Algorithm</dt><dd></dd></dl>
<ul>
<li>Verifies that the component function is supported</li>
<li>If the selected function is "const", then copies the LdFunDta in LdRes. And go out.</li>
<li>Copy subcomponents data list and apply the function</li>
<li>Apply function of the component<ul>
<li>For each subcomponent:<ul>
<li>If NOT a VECTOR</li>
<li>- IF it is the first one and the treated function is not the MCI_PAY_OFF_CMP_TYP_IF, the 'LdFunDta' data list is duplicated and saved into LdCalDta</li>
<li>- IF NOT, the function is applied with LdCalDta and the 'LdFunDta' of the treated subcomponent. And the result is saved into LdCalDta. If the treated function is a MCI_PAY_OFF_CMP_TYP_IF, verify its condition and take the THEN or the ELSE part depending on it. It treats nested IFs. When an IF is solved, it exits this bucle.</li>
<li>If VECTOR</li>
<li>- Concat all the LdFunDta lists of the component and copy it in LdRes if:<ul>
<li>vector without different fixing dates for its elements</li>
<li>if not a condition</li>
<li>or not on date</li>
</ul>
</li>
<li>- If not, concats the 'LdFunDta' list</li>
<li>- Set the calculated list into the 'LdRes'</li>
</ul>
</li>
</ul>
</li>
<li>If NOT a VECTOR, set the calculated component into the LdFxg list, column "LdRes" (after calculating all subcomponents). If it is the first time doing it, it adds a column called 'NbFxd'), to be equal to the previous fixed initial values list. </li>
</ul>

</div>
</div>
<a class="anchor" id="a292fc7de0040e4574296a3568e9c9311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgAplCnd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the condition function. </p>
<p>Apply the condition function to the data lists of it. The functions implemented by the moment are: "max", "min", "avg", "return", "sum", "vec" (returns the last element of a list). The calculation way is different if it is a vector or not:</p>
<ul>
<li>Vector: the condition is applied to each component</li>
<li>Not vector: the condition is applied to each component<ul>
<li>If only one subcomponent: the condition is applied to this subcomponent</li>
<li>If multiples subcomponents: the condition is applied to all the subcomponents. Example: 'SUM' it will be the sum of the result of the condition plus the previous fixed initial values.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>List with the conditions to be fixed </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of the treated condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 22/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 28/Nov/2007: Set as unknown when there is a not treated function</li>
<li>Jon BARRUTIA - 30/Nov/2007: Warning messages instead of info</li>
<li>Jon BARRUTIA - 05/Dec/2007: Treat the "vec" condition type</li>
<li>Jon BARRUTIA - 10/Jan/2008: Different ways to apply a condition</li>
<li>Jon BARRUTIA - 22/Jan/2008: Call to lcMCIfxgAplCndFcn. If marked as not to calculate, go out. Possible case: functions not implemented yet. Write the calculated result in all lines for the treated condition (New column). Treat the case that the condition should be applied to only one vector element because the rest are not OnDat.</li>
<li>Jon BARRUTIA - 07/Feb/2008: When component with only one subcomponent, apply the function to the 'LdRes' list.</li>
<li>Jon BARRUTIA - 11/Feb/2008: Use macrodefinitions for size of some columns</li>
<li>Jon BARRUTIA - 15/Feb/2008: Call to lcMCIfxgSetCndAsRes to copy the calculated condition into the LdRes data list also for the not vector components. Otherwise, they only are into the New column, problems when using them as a subcomponent.</li>
</ul>
<dl class="section user"><dt>Algorithm</dt><dd></dd></dl>
<ul>
<li>IF VECTOR or only one subcomponent: -+ apply condition function to each subcomponent and set in 'LdRes' (first line of the component) a concatenation of the calculated results. If only one subcomponent, use 'LdRes' to apply the function.</li>
<li>ELSE -+ If marked as not to calculate, do nothing (possible case: functions not implemented yet). -+ apply the condition function to all subcomponents at same time: The result is unique for the condition. We suppose that in LdRes we have the previous fixed initial values and the calculated for the fixing date. We apply the condition and copy the result to the LdRes list.</li>
<li>Set in 'LdRes' (first line of the component) a concatenation of the calculated results.</li>
<li>Not vectors: Write the calculated result in all lines for the treated condition (column 'New'). This is done to be able to remove duplicated lines for a condition and show only one. </li>
</ul>

</div>
</div>
<a class="anchor" id="a70281efb4a43f645a9dfe7eec1bd19f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgAplCndFcn </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the condition function. </p>
<p>Apply the condition function to the data lists of it. The functions implemented by the moment are:</p>
<ul>
<li>MCI_POC_AVG: Average</li>
<li>MCI_POC_MAX: Maximum</li>
<li>MCI_POC_MIN: Minimum</li>
<li>MCI_POC_PRD: Product</li>
<li>MCI_POC_RET: Return</li>
<li>MCI_POC_SUM: Sum</li>
<li>MCI_POC_VEC: Vector It marks as known if the condition is calculated correctly.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>List with the conditions to be fixed </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of the treated condition </td></tr>
    <tr><td class="paramname">LdDta</td><td>List with the data which the condition is fixed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 22/Jan/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 11/Feb/2008: Correct average calculation for components</li>
<li>Jon BARRUTIA - 12/Feb/2008: Added the 'return' for the conditions that have an 'asset' type subcomponent.</li>
<li>Jon BARRUTIA - 15/Feb/2008: Use column indexes instead of their names</li>
<li>Jon BARRUTIA - 20/Feb/2008: Treat the "prod" condition function </li>
</ul>

</div>
</div>
<a class="anchor" id="afe01f246ff9f3742af057bab63136335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgAplSubCmpFun </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntDta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the configured component function to market data used in fixing treatment. </p>
<p>Apply the configured component function to market data used in fixing treatment. By the moment, the only functions that are managed are:</p>
<ul>
<li>- MCI_PAY_OFF_CMP_TYP_CAL ("call")</li>
<li>- MCI_PAY_OFF_CMP_TYP_CTE ("const")</li>
<li>- MCI_PAY_OFF_CMP_TYP_DIG ("dig")</li>
<li>- MCI_PAY_OFF_CMP_TYP_IF ("if")</li>
<li>- MCI_PAY_OFF_CMP_TYP_MAX ("max")</li>
<li>- MCI_PAY_OFF_CMP_TYP_MIN ("min")</li>
<li>- MCI_PAY_OFF_CMP_TYP_PRD ("prod")</li>
<li>- MCI_PAY_OFF_CMP_TYP_PRT ("tprior")</li>
<li>- MCI_PAY_OFF_CMP_TYP_PUT ("put")</li>
<li>- MCI_PAY_OFF_CMP_TYP_RET ("return")</li>
<li>- MCI_PAY_OFF_CMP_TYP_RND ("round")</li>
<li>- MCI_PAY_OFF_CMP_TYP_RNG ("range")</li>
<li>- MCI_PAY_OFF_CMP_TYP_RNK ("rank")</li>
<li>- MCI_PAY_OFF_CMP_TYP_SUM ("sum")</li>
<li>- MCI_PAY_OFF_CMP_TYP_VEC ("vector")</li>
<li>- MCI_PAY_OFF_CMP_TYP_VRN ("vrank")<ul>
<li>When a component function is not treated, the component is set as unknown and not calculable</li>
<li>Usually, the function defined for the components is applied to each subcomponent and these results are summed. There are exceptions as PROD..., see the FEA doc.</li>
<li>When treating the "if", the 'then' and 'else' components won't be treated except for the 'else' that has a nested 'if'.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdDta</td><td>List with the informatin of the deal for which the fixing is done </td></tr>
    <tr><td class="paramname">CntDta</td><td>Index in the data list that correspond to the fixed deal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Josune BIKUNA - 10/Sep/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Josune BIKUNA - 10/Sep/2007: Set different default values for amount, weight and strike depending on the function to apply</li>
<li>Josune BIKUNA - 10/Sep/2007: Avoid compilation warnings when calling to lcMCIfxgFndPvb</li>
<li>Jon BARRUTIA - 21/Nov/2007: Treat also: MCI_PAY_OFF_CMP_TYP_SUM, MCI_PAY_OFF_CMP_TYP_MAX MCI_PAY_OFF_CMP_TYP_MIN, MCI_PAY_OFF_CMP_TYP_CTE</li>
<li>Jon BARRUTIA - 23/Nov/2007: Amount, weight and strike are already set into the data list</li>
<li>Jon BARRUTIA - 23/Nov/2007: Modify calculation way</li>
<li>Jon BARRUTIA - 23/Nov/2007: Rename: lcMCIfxgAplCmpFun &ndash;&gt; lcMCIfxgAplSubCmpFun</li>
<li>Jon BARRUTIA - 28/Nov/2007: Set as unknown when the called function is not treated</li>
<li>Jon BARRUTIA - 30/Nov/2007: Warning messages instead of info</li>
<li>Jon BARRUTIA - 03/Dec/2007: MCI_PAY_OFF_CMP_TYP_VEC treated</li>
<li>Jon BARRUTIA - 22/Jan/2007: Correct the treatment for MCI_PAY_OFF_CMP_TYP_RNG, MCI_PAY_OFF_CMP_TYP_DIG</li>
<li>Jon BARRUTIA - 24/Jan/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_IF</li>
<li>Jon BARRUTIA - 31/Jan/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_PRD,MCI_PAY_OFF_CMP_TYP_CAL and MCI_PAY_OFF_CMP_TYP_PUT</li>
<li>Jon BARRUTIA - 04/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_PRT</li>
<li>Jon BARRUTIA - 04/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_RND</li>
<li>Jon BARRUTIA - 18/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_RET</li>
<li>Jon BARRUTIA - 20/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_RNK</li>
<li>Jon BARRUTIA - 22/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_VRN</li>
<li>Jon BARRUTIA - 28/Mar/2008: Treat max,min and prod as the sum when v-&gt;s wanted</li>
<li>Jon BARRUTIA - 31/Mar/2008: Correct sum treatment for dig and range </li>
</ul>

</div>
</div>
<a class="anchor" id="ac7ed24eb91e26c6b15e47f4f7956ca8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgCalCmp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMktFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMktCmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subcomponents initial values list calculation. </p>
<p>Recursive function that calculates the subcomponents initial values list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database connection </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of alias </td></tr>
    <tr><td class="paramname">LdFxg</td><td>List with the conditions to be fixed </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of the treated condition </td></tr>
    <tr><td class="paramname">LdMktFxg</td><td>List with the market data of the assets </td></tr>
    <tr><td class="paramname">LdMktCmp</td><td>List with the fixed initial values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 22/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 28/Nov/2007: Mark subcmponents as not calculables when it is not calculated</li>
<li>Jon BARRUTIA - 28/Dec/2007: If not a condition, get only market data for the fixing date</li>
<li>Jon BARRUTIA - 22/Jan/2008: Components calculated outside</li>
<li>Jon BARRUTIA - 04/Feb/2008: Treat the tprior payoff function</li>
<li>Jon BARRUTIA - 23/Mar/2009: Add the "VecEle" column for vector elements data</li>
</ul>
<dl class="section user"><dt>Algorithm</dt><dd></dd></dl>
<ul>
<li>For each subcomponent of the treated component:<ul>
<li>Verify if it is already known, and if so continue</li>
<li>If it is an asset or constant or tprior<ul>
<li>Get market data lines</li>
<li>If not a condition, get only market data for the fixing date</li>
<li>If vector, set the element identifier of each one</li>
<li>Set the calculated component into the LdFxg list, column "LdFunDta"</li>
<li>Apply to each market data the function associated to the component type</li>
</ul>
</li>
<li>If it is a component<ul>
<li>Call recursively this function </li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a9a03d05511feda0567aeda9375784284"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgCalOneLop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMktFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMktCmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AllFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Oth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the initial values for some conditions. </p>
<p>Calculate the initial values for those conditions that is possible in this moment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database connection </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of alias </td></tr>
    <tr><td class="paramname">LdFxg</td><td>List with the conditions to be fixed </td></tr>
    <tr><td class="paramname">LdDat</td><td>List with the dates to fix any condition </td></tr>
    <tr><td class="paramname">LdMktFxg</td><td>List with the market data of the assets </td></tr>
    <tr><td class="paramname">LdMktCmp</td><td>List with the fixed initial values </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">AllFxg</td><td>If already fixed initial values should be re-calculated (1) or not (0) </td></tr>
    <tr><td class="paramname">Oth</td><td>(out) If another loop should be launched (1) or not (0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section user"><dt>Algorithm</dt><dd></dd></dl>
<ul>
<li>Extract the initial values that can be fixed. Which ones?</li>
<li>+ conditions which component is an asset</li>
<li>+ components that are constants (this is marked after the market data checking)</li>
<li>+ conditions which component is a component already fixed</li>
<li>Remove the conditions that are already fixed</li>
<li>If there is not any condition to fix, go out</li>
<li>Fix the conditions</li>
<li>+ Check the MKT</li>
<li>+ Calculate the initial values of the subcomponents</li>
<li>+ Calculate the initial values of the components</li>
<li>Fix the condition</li>
<li>Save the calculated initial values into the components market data structure</li>
<li>Specify that another loop should be done</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 16/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 20/Nov/2007: Get market data taking into account the type of the condition</li>
<li>Jon BARRUTIA - 21/Nov/2007: Market data recovered outside. Save calculated initial values into the components market data structure</li>
<li>Jon BARRUTIA - 21/Nov/2007: Do not fix component that is not a condition</li>
<li>Jon BARRUTIA - 21/Nov/2007: Use the condition-subcomponent pair to set correctly the calculated value</li>
<li>Jon BARRUTIA - 26/Nov/2007: Component fixing corrected</li>
<li>Jon BARRUTIA - 28/Nov/2007: Condition applied also if there is component data list</li>
<li>Jon BARRUTIA - 27/Dec/2007: Corrected the way to save calculated data into the components market data structure. Modified the condition application method. The components are calculated here.</li>
<li>Jon BARRUTIA - 09/Jan/2008: lcMCIfxgChkMkt needs the fixing date as argument</li>
<li>Jon BARRUTIA - 10/Jan/2008: lcMCIfxgAplCmpFun has the fixing date as argument Mark as fixable if the component is a constant. The components are calculated after all sub-components. The conditions are calculated after all components.</li>
<li>Jon BARRUTIA - 31/Jan/2008: lcMCIfxgChkMkt: Ctx argument not needed</li>
<li>Jon BARRUTIA - 31/Jan/2008: Remove the treatment that saves the calculated initial values for components. They are not needed.</li>
<li>Jon BARRUTIA - 04/Feb/2008: Treat the tprior payoff function</li>
<li>Jon BARRUTIA - 28/Mar/2008: 'tprior' is set as ToFix=0 because they are solved before the loop of calculations. Call to lcMCIfxgMrkKnwSbc, to mark the subcomponent Knw field.</li>
</ul>
<dl class="section user"><dt>Algorithm</dt><dd></dd></dl>
<ul>
<li>Extract the initial values that can be fixed. Which ones? -+ conditions which component is an asset (Column SubTyp == 'ass') -+ components that are not on date; they may be used to fix other ones -+ components that are constants (this is marked after the market data checking) -+ conditions which component is a component already fixed (Column 'New' with valid data)</li>
<li>Remove the conditions that are already fixed: A condition is already fixed if there is value for all dates for the market data</li>
<li>If there is not any condition to fix, go out</li>
<li>Check the market data</li>
<li>Fix the conditions<ul>
<li>For each component, calculate its initial value<ul>
<li>Not recalculate the value to fix because it has one</li>
<li>Verify if it is not a constant or tprior and it has been calculated, and if so continue</li>
<li>Calculate each sub-component of the condition</li>
<li>Calculate the component</li>
<li>Mark as known all components that have it as subcomponent</li>
</ul>
</li>
</ul>
</li>
<li>Apply conditions:<ul>
<li>Get the conditions to be applied:<ul>
<li>Components that have conditions</li>
<li>Components that have ToFix to 1 for all subcomponents</li>
</ul>
</li>
<li>Apply conditions</li>
</ul>
</li>
<li>Specify that another loop should be done </li>
</ul>

</div>
</div>
<a class="anchor" id="aa7b8937ca97516d45fab411965206ec2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgChkMkt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AllFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the existence of the market data to fix the initial values. </p>
<p>Check the existence of the market data to fix the initial values. For the components, it does not check the existence of the market data for the fixing date (it will be calculated by the fixing treatment). Do not control assets if controlling component market data existence; and viceversa. If controlling components:</p>
<ul>
<li>if the subcomponent is not a condition, do not control.</li>
<li>if the condition begin date is greater or equal to the calculation date, do not control. From all the dates, take only the last one belonging to the condition:</li>
<li>If checking market data for a not condition, check for the fixing date instead of the init and end dates.</li>
<li>Otherwise, takes the fixing date as checking date</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>List with the fixing data that will be fixed when calling to the function </td></tr>
    <tr><td class="paramname">LdDat</td><td>List with the fixing dates for all conditions of the instrument. </td></tr>
    <tr><td class="paramname">LdMkt</td><td>List with the market data </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">Mkt</td><td>1: market data: 0:component initial values </td></tr>
    <tr><td class="paramname">AllFxg</td><td>If the already fixed components must be re-calculated or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 16/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 20/Nov/2007. Remove added column (mrk) from LdDat. Correct the control if there are prices for all dates. If not recalculate the initial value do not control.</li>
<li>Jon BARRUTIA - 27/Nov/2007. Correct the way to know if there are some prices missing</li>
<li>Jon BARRUTIA - 11/Dec/2007. Correct warning messages when no prices</li>
<li>Jon BARRUTIA - 27/Dec/2007. Vector elements data in warning messages. The subcomponents are also controlled when controlling the components and the subcomponent is not an asset.</li>
<li>Jon BARRUTIA - 28/Dec/2007. Do not take into account in the checking the current fixing date</li>
<li>Jon BARRUTIA - 09/Jan/2008: Add the fixing date as argument and use it instead of taking it from the fixing data list. Warning messages format modified.</li>
<li>Jon BARRUTIA - 09/Jan/2008: Correct the message format</li>
<li>Jon BARRUTIA - 22/Jan/2008: Correct the message format when no prices are found (none). Added the instrument to the warning messages. If checking market data for a not condition, check for the fixing date instead of the init and end dates.</li>
<li>Jon BARRUTIA - 28/Jan/2008: Improved messages to know when ask for MKT or for fixings</li>
<li>Jon BARRUTIA - 28/Jan/2008: Use subcomponent type instead of the 'Mkd' argument to know if components or assets are treated.</li>
<li>Jon BARRUTIA - 28/Jan/2008: Take into account if the condition is on date or not. For conditions, check only the existence of the last fixed date. Also, check when number of fixing dates and number of market data are the same to verify that the date is the same in both cases.</li>
<li>Jon BARRUTIA - 31/Jan/2008: Ctx argument not needed</li>
<li>Jon BARRUTIA - 31/Jan/2008: Conditions dates list does not contain the previous dates to the last one. Not control only for same dates, control if a market datum comes for the condition date.</li>
<li>Jon BARRUTIA - 01/Feb/2008: Corrections when the fixing dates list is empty</li>
<li>Josune BIKUNA - 22/Oct/2008: Use CLINT type instead of int in cardinal functions</li>
<li>Nerea RAMOS - 20/Jan/2012: Set correctly DatCnd type void * -&gt; char *, to avoid HP warning 2181-D: argument is incompatible with corresponding format string conversion</li>
<li>Basilio TAMAYO - 19/Sep/2012: DYNaddColumns and DYNajoutexCol must have size with type size_t</li>
</ul>
<dl class="section user"><dt>Algorithm</dt><dd></dd></dl>
<ul>
<li>For components (Mkt == 0), use a market data list without the current fixing date data</li>
<li>For each component:<ul>
<li>If the 'AllFxg' argument is specified to not recalculate the initial value, do not control</li>
<li>Do not control assets if controlling component market data existence; and viceversa.</li>
<li>If controlling components, if the subcomponent is not a condition, do not control</li>
<li>If controlling components, if the condition begin date is greater or equal to the calculation date, do not control</li>
<li>If the component has a condition, from all the dates, take only those belonging to the condition. For components, from all the dates, remove the fixing date.</li>
<li>Get lines for the treated UMC</li>
<li>Control if there are any price</li>
<li>Control if there are prices for all dates</li>
<li>Control if the prices for the asked date is into the market data list </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a399889912cec738aa108e53260c05ed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgChkMktNotOnDat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AllFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that the needed initial values of conditions are already fixed. </p>
<p>Checks that the needed initial values of conditions are already fixed. They should come into the market data structure of components. It is a specific checking function done for the components that are not on date. The generic checking function is launched for the components that are not on date. Also, the components of asset type are checked because they are used. They are conditions that have been fixed previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">LdFxg</td><td>List with the fixing data that will be fixed when calling to the function </td></tr>
    <tr><td class="paramname">LdDat</td><td>List with the fixing dates for all conditions of the instrument. </td></tr>
    <tr><td class="paramname">LdMkt</td><td>List with the market data of components </td></tr>
    <tr><td class="paramname">AllFxg</td><td>If the already fixed components must be re-calculated or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 08/Jan/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 31/Jan/2008: lcMCIfxgChkMkt: Ctx argument not needed so this function neither </li>
</ul>

</div>
</div>
<a class="anchor" id="ac02d19f27f642e3a2a0ee2f7b9a3d595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgCnf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>FxgDat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Confirm inital values for selected instruments. </p>
<p>Confirm all the initial values realated to some intruments in a given date</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database connexion </td></tr>
    <tr><td class="paramname">LdDta</td><td>Data list </td></tr>
    <tr><td class="paramname">FxgDat</td><td>Date</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ismael SERRANO - 28/Jun/2007:</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 30/Aug/2007: Taken from EMCIfxgCnf</li>
<li>Jon BARRUTIA - 05/Sep/2007: OldVal, NewVal substitued by Val. MaxEle removed.</li>
<li>Jon BARRUTIA - 09/Nov/2007: Save also the AssCmp column</li>
<li>Jon BARRUTIA - 05/Dec/2007: Save also the VecEle column</li>
<li>Jon BARRUTIA - 06/Dec/2007: Correct initial values modifications</li>
<li>Jon BARRUTIA - 06/Dec/2007: Correct again</li>
<li>Basilio TAMAYO - 19/Sep/2012: DYNaddColumns and DYNajoutexCol must have size with type size_t</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="a09fd191950d493d5837f66549e9ae9e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgFndPvb </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdPvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ValFld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Als</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntDta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>DtaOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>VldOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain the value of a string type variable parameter. </p>
<p>Obtain the value of a string type variable parameter for a given deal. Given a variable parameter field, its value will be first searched in the list of variable parameters passed as parameter, and if it is not found, it will be searched in the data list passed also as parameter.</p>
<ul>
<li>The variable parameter list must have at least the following columns:</li>
<li>- "TcNum" : number of the deal for which the variable parameter corresponds to</li>
<li>- "CodPar": field name of the variable parameter</li>
<li>- "ValDat": value of the variable parameter OR</li>
<li>- "ValNum": value of the variable parameter</li>
<li>- "als" : alias of the database for which the deal corresponds to. This column is only obligatory in case a specific book is required, this is, the Als parameter is valid.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdPvb</td><td>List of variable parameters </td></tr>
    <tr><td class="paramname">ValFld</td><td>Name of the field in the list of variable parameters where the value to recover is store ("ValDat", "ValNum", ...) </td></tr>
    <tr><td class="paramname">Als</td><td>Alias of the book for which the value is required </td></tr>
    <tr><td class="paramname">Num</td><td>Number of the deal for which the value is required </td></tr>
    <tr><td class="paramname">Fld</td><td>Name of the variable parameter field for which the value is required </td></tr>
    <tr><td class="paramname">LdDta</td><td>List of data used to search the value in case the variable parameter is not present in the variable parameters list </td></tr>
    <tr><td class="paramname">CntDta</td><td>Index in the data list where the value must be searched </td></tr>
    <tr><td class="paramname">DtaOut</td><td>(OUT) Searched value </td></tr>
    <tr><td class="paramname">VldOut</td><td>(OUT) Validity flag of th searched value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Josune BIKUNA - 07/Sep/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Josune BIKUNA - 10/Sep/2007: Adapt it to any type of returned data</li>
<li>Jon BARRUTIA - 16/Nov/2007: Do not use binary search</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="a9f20aa5cc95de43061c044e009261ed6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgFndTdt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>TimCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdTdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>TdtVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>VldOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value depending on a time dependent table. </p>
<p>Returns the value depending on a time dependent table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdFxg</td><td>Fixing data list </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Treated index </td></tr>
    <tr><td class="paramname">TimCol</td><td>Column where the tdt code is saved </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">LdTdt</td><td>Tdt list </td></tr>
    <tr><td class="paramname">TdtVal</td><td>(out). Returned value </td></tr>
    <tr><td class="paramname">VldOut</td><td>(out). Flag that indicates the validity of the returned value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 01/Feb/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Gema ACHA - 28/Feb/2008: Add deal number to MCItimFndTdt function</li>
<li>Gema ACHA - 28/Feb/2008: Add time depentent table list MCItimFndTdt function</li>
<li>Jon BARRUTIA - 09/Dec/2008: MCItimFndTdt needs the deal identifier as argument</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="a285405835818c5b9e2fef4b83d23ca81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgFulFxgMci </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciPvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciTdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix the initial values for some components. </p>
<p>Automatic fixing of the running average for the components passed in LdFxg. Calculations:</p>
<ul>
<li>Treat vector elements (new line for each vector element)</li>
<li>Get already existent fixed initial values</li>
<li>Calculates a dates list with all dates necessary for each condition. And sets into the list, 'LdFxd' column, the fixing dates list for each of them.</li>
<li>Convert equivalent payoff functions. E.g.: stop -&gt; if</li>
<li>Mark calculable lines and already known components</li>
<li>Set the internal 'then' and 'else' functions to the IF function</li>
<li>Complete the amount, weight and strike values for each component</li>
<li>Get market data</li>
<li>'Knw' is set to 1 to those components that are not OnDat and are used as subcomponents.</li>
<li>Create constants data lists</li>
<li>Calculate the initial values for all conditions.</li>
<li>Apply the sub-component function to the not OnDat components. Once all are applied, the component function is applied.</li>
<li>Solve the 'tprior' functions. The do not depend on other components resolution. Their behaviour is similar to the constans.</li>
<li>Purge of the initial values for the incorrect fixing dates</li>
<li>The calculations are launched in loops, that is, each loop launches the initial values calculation that are possible at that time.</li>
<li>Each loop saves the calculated initial values into the component market data structure to be accesible in following loops.</li>
<li>After all calculations, substitute the calculated value for the 'return' condition (only for subcomponents of 'asset' type). It will be the price in the fixing date.</li>
<li>Return only the conditions</li>
<li>Remove sublist columns of LdFxg It does not remove the conditions that are not on date and are not used as subcomponents, so a warning will be appear although the condition is not used. It is OK because it should exist because it is a previous condition. It should be already calculated. If not, when it will be calculated, all the future fixings are removed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of book alias over which the fixing is being done </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">LdFxg</td><td>(in / out). List with the fixing data. A new column is added: "FxgVal". </td></tr>
    <tr><td class="paramname">LdMciPvb</td><td>Variable parameters list </td></tr>
    <tr><td class="paramname">LdMciTdt</td><td>Tdt list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 28/Aug/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 27/Jan/2009: Add column 'AllFxgDat' for all cases; also when it exits before finish the function</li>
<li>Jon BARRUTIA - 23/Feb/2009: lcMCIfxgGetAllFxgDat receives the LdMciTdt argument</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="mci_fxg_8c.html#a3bc9fedd782ff2c54aa4fad21c4d542d" title="Fix the initial values for some components.">lcMCIfxgFxgMci</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6768c3781acb0077630e6882a61569c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgFxg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Pro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AllFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix the initial values for some instruments. </p>
<p>Fix the initial values for some instruments. It does a loop taking in each one data of one deal-instrument. This is done because the fixing treatment is not prepared to know the distinct dates of each component; so to approximate to it, the distinct dates for a instrument are taken.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of book alias over which the fixing is being done </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">Pro</td><td>Profile to recover market data </td></tr>
    <tr><td class="paramname">Fix</td><td>Fix the initial values (1) or only read the existent ones (0) </td></tr>
    <tr><td class="paramname">AllFxg</td><td>If the already fixed components must be re-calculated or not </td></tr>
    <tr><td class="paramname">LdFxg</td><td>List with the fixing data </td></tr>
    <tr><td class="paramname">LdOut</td><td>(out). List with the fixed initial values. It is a copy of the LdFxg list with a "New" column with the calculated value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 07/Dec/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 10/Dec/2007: MCIfxgFxg &ndash;&gt; MCIfxgFxgMci</li>
<li>Jon BARRUTIA - 10/Dec/2007: MCIfxgFxgAll &ndash;&gt; MCIfxgFxg</li>
<li>Jon BARRUTIA - 18/Dec/2007: MCIfxgFxg &ndash;&gt; lcMCIfxgFxg (private)</li>
<li>Jon BARRUTIA - 08/Jan/2008: MCIfxgFxgMci &ndash;&gt; lcMCIfxgFxgMci</li>
<li>Jon BARRUTIA - 09/Jan/2008: lcMCIfxgFxgMci has a new parameter: fixing date</li>
<li>Jon BARRUTIA - 13/Feb/2008: lcMCIfxgFxgMci has a new parameter: purging flag</li>
<li>Jon BARRUTIA - 22/Abr/2008: Do not return components that are not calculables</li>
<li>Gema ACHA - 16/May/2008: lcMCIfxgFxgMci has a new parameter: time dependent table list</li>
<li>Jon BARRUTIA - 07/Jul/2009: show fixing data in view mode</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="mci_fxg_8c.html#a3bc9fedd782ff2c54aa4fad21c4d542d" title="Fix the initial values for some components.">lcMCIfxgFxgMci</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc9fedd782ff2c54aa4fad21c4d542d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgFxgMci </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Pro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AllFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciPvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciTdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Pur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fix the initial values for some components. </p>
<p>Automatic fixing of the running average for the components passed in LdFxg. If 'Fix' is equal to zero, it returns the existent initial values. Otherwise, it launches the calculations:</p>
<ul>
<li>Treat vector elements (new line for each vector element)</li>
<li>Get already existent fixed initial values</li>
<li>Calculates a dates list with all dates necessary for each condition. And sets into the list, 'LdFxd' column, the fixing dates list for each of them.</li>
<li>Convert equivalent payoff functions. E.g.: stop -&gt; if</li>
<li>Mark calculable lines and already known components</li>
<li>Set the internal 'then' and 'else' functions to the IF function</li>
<li>Complete the amount, weight and strike values for each component</li>
<li>Get market data</li>
<li>'Knw' is set to 1 to those components that are not OnDat and are used as subcomponents.</li>
<li>Create constants data lists</li>
<li>Calculate the initial values for all conditions.</li>
<li>Apply the sub-component function to the not OnDat components. Once all are applied, the component function is applied.</li>
<li>Solve the 'tprior' functions. The do not depend on other components resolution. Their behaviour is similar to the constans.</li>
<li>Purge of the initial values for the incorrect fixing dates</li>
<li>The calculations are launched in loops, that is, each loop launches the initial values calculation that are possible at that time.</li>
<li>Each loop saves the calculated initial values into the component market data structure to be accesible in following loops.</li>
<li>After all calculations, substitute the calculated value for the 'return' condition (only for subcomponents of 'asset' type). It will be the price in the fixing date.</li>
<li>Return only the conditions</li>
<li>Remove sublist columns of LdFxg It does not remove the conditions that are not on date and are not used as subcomponents, so a warning will be appear although the condition is not used. It is OK because it should exist because it is a previous condition. It should be already calculated. If not, when it will be calculated, all the future fixings are removed.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of book alias over which the fixing is being done </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">Pro</td><td>Profile to recover market data </td></tr>
    <tr><td class="paramname">Fix</td><td>Fix the initial values (1) or only read the existent ones (0) </td></tr>
    <tr><td class="paramname">AllFxg</td><td>If the already fixed components must be re-calculated or not </td></tr>
    <tr><td class="paramname">LdFxg</td><td>(in / out). List with the fixing data. A new column is added: "FxgVal". </td></tr>
    <tr><td class="paramname">LdMciPvb</td><td>Variable parameter list </td></tr>
    <tr><td class="paramname">LdMciTdt</td><td>Time parameter list </td></tr>
    <tr><td class="paramname">Pur</td><td>Purge incorrect fixed initial values (1) or not (0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 28/Aug/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 30/Aug/2007: Corrected call to MCIfxgGetLstDat</li>
<li>Jon BARRUTIA - 31/Aug/2007: Corrected names of the passed list.</li>
<li>Jon BARRUTIA - 05/Sep/2007: OldVal, NewVal substitued by Val</li>
<li>Jon BARRUTIA - 05/Sep/2007: No prices messages show current date as end date</li>
<li>Ramon MARTINEZ - 06/Sep/2007: Not delete lines after MCIfxgGetLstDat because they are deleted in the functions. Calculate NbPriDat from LdDatUmc</li>
<li>Josune BIKUNA - 07/Sep/2007: If there are not prices for all the necessary dates, shown a warning message only with those dates for which the market data is missing</li>
<li>Josune BIKUNA - 07/Sep/2007: For each deal, calculate the fixing value only using the market data in the dates needed for it</li>
<li>Josune BIKUNA - 10/Sep/2007: Add book aliases list as parameter</li>
<li>Josune BIKUNA - 10/Sep/2007: Before carrying out the fixing calculations with the correspondent market dsts, apply to each market data the function associated to the component type</li>
<li>Josune BIKUNA - 10/Sep/2007: Inti the "New" column to flat value 0.0 instead of 0</li>
<li>Josune BIKUNA - 19/Sep/2007: Sort correctly the list of prices before adding them to the data list</li>
<li>Josune BIKUNA - 25/Sep/2007: Add Adj, AdjScp and AddDat parameters when calling to MCIfxgGetLstDat function.</li>
<li>Jon BARRUTIA - 05/Oct/2007: The fixing date is taken from the conditions list</li>
<li>Jon BARRUTIA - 10/Oct/2007: Not recalculate the value to fix because it has not begin</li>
<li>Jon BARRUTIA - 09/Nov/2007: Correct the market data recovering when dates number exceeds the size of the variable where the where clause is saved.</li>
<li>Josune BIKUNA - 13/Nov/2007: take into account the flag 'Mdb' (modify dates in block) of the instrument for calculating the fixing open dates.</li>
<li>Josune BIKUNA - 20/Nov/2007: Rename AdjScp -&gt; AdjSco</li>
<li>Jon BARRUTIA - 26/Nov/2007: Fixing of components</li>
<li>Jon BARRUTIA - 30/Nov/2007: Return only the condition lines</li>
<li>Jon BARRUTIA - 04/Dec/2007: Initialise the vector's elements codes</li>
<li>Jon BARRUTIA - 04/Dec/2007: Added the recovering of the already fixed initial values</li>
<li>Jon BARRUTIA - 06/Dec/2007: Added new argument "Fix" to indicate if calculations must be launched. Needed because this function is also used to only recover the existent initial values.</li>
<li>Jon BARRUTIA - 06/Dec/2007: If there is any error, do set all fixing values to zero</li>
<li>Jon BARRUTIA - 10/Dec/2007: MCIfxgFxg &ndash;&gt; MCIfxgFxgMci</li>
<li>Jon BARRUTIA - 27/Dec/2007: OnDat column used to mark if a component initial values are known or not. Recover initial values for all fixing dates.</li>
<li>Jon BARRUTIA - 07/Jan/2008: Add LdMciPvb argument to convert amount, weight and strike with the variable parameters</li>
<li>Jon BARRUTIA - 08/Jan/2008: Sort initial values list before doing the join. MCIfxgFxgMci &ndash;&gt; lcMCIfxgFxgMci</li>
<li>Jon BARRUTIA - 11/Jan/2008: Retrieve initial values for all fixing dates. Add LdRes column to save calculated component values. lcMCIfxgGetMktCmp, lcMCIfxgAplCmpFun have the fixing date as argument. Remove the sublists columns from the returned list. 'Knw' is set to 1 to those components that are not OnDat and are used as subcomponents. lcMCIfxgGetAllFxgDat does not need the AllFxg argument.</li>
<li>Jon BARRUTIA - 24/Jan/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_IF (also treat nested IF functions). Fixing date added as argument in lcMCIfxgGetAllFxgDat.</li>
<li>Jon BARRUTIA - 30/Jan/2008: lcMCIfxgGetAllFxgDat does not need the Lin argument</li>
<li>Jon BARRUTIA - 31/Jan/2008: lcMCIfxgChkMktNotOnDat: Ctx argument not needed</li>
<li>Jon BARRUTIA - 31/Jan/2008: Remove the conditions that are not on date and are not used as subcomponents to avoid warnings on not treated conditions.</li>
<li>Jon BARRUTIA - 04/Feb/2008: Solve the 'tprior' functions</li>
<li>Jon BARRUTIA - 04/Feb/2008: lcMCIfxgSetAmoWeiStk needs the fixing date as argument.</li>
<li>Jon BARRUTIA - 12/Feb/2008: After all calculations, substitute the calculated value for the 'return' condition. It will be the price in the fixing date.</li>
<li>Jon BARRUTIA - 12/Feb/2008: Purge of the initial values for the incorrect fixing dates.</li>
<li>Jon BARRUTIA - 14/Feb/2008: Purge of "LdPurFxd"</li>
<li>Jon BARRUTIA - 14/Feb/2008: Do not remove the conditions that are not on date and are not used as subcomponents.</li>
<li>Jon BARRUTIA - 15/Feb/2008: lcMCIfxgGetMkt uses the fixing date and Pur parameters</li>
<li>Jon BARRUTIA - 15/Feb/2008: Convert equivalent payoff functions. E.g.: stop -&gt; if</li>
<li>Jon BARRUTIA - 25/Mar/2008: Neither show the components that are not calculables</li>
<li>Jon BARRUTIA - 22/Abr/2008: Return components that are not calculables because this function is called from the DLE and it need conditions fixed previously, so, ToCal = 0.</li>
<li>Jon BARRUTIA - 28/Abr/2008: Add 'ToCal' column before using it in View mode. Otherwise, it crashes.</li>
<li>Gema ACHA - 16/May/2008: Add a new parameter: time dependent table list</li>
<li>Jon BARRUTIA - 09/Jul/2008: Add new argument to lcMCIfxgGetAllFxgDat</li>
<li>Jon BARRUTIA - 17/Dec/2008: lcMCIfxgGetAllFxgDat has a new argument</li>
<li>Jon BARRUTIA - 23/Feb/2009: lcMCIfxgGetAllFxgDat has a new argument: LdMciTdt</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="mci_fxg_8c.html#af6768c3781acb0077630e6882a61569c" title="Fix the initial values for some instruments.">lcMCIfxgFxg</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeb4979da7d13b62d21d64ed4d96f6deb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgGetAllFxgDat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>All</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciTdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>NedFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets fixing dates. </p>
<p>Gets fixing dates for the conditions passed in 'LdFxg'. It returns a list with the fixing dates of all conditions or the fixing dates of one condition if a index is passed by argument ('Lin'). If the condition is not on date, the dates list will contain only the component fixing date. Also, the last fixing date for each condition is set into the 'LdFxg' list on the 'LdFxd' column. Also, all fixing dates for each condition are set into the 'LdFxg' list on the 'LdPurFxd' column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>Diffusion books list </td></tr>
    <tr><td class="paramname">LdFxg</td><td>Fixing data list. Columns called 'LdFxd', 'LdPurFxd' are added. </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">All</td><td>Get all fixing dates (1) or only those to be treated (0) </td></tr>
    <tr><td class="paramname">LdMciTdt</td><td>Tdt list </td></tr>
    <tr><td class="paramname">LdDat</td><td>(out) list of fixing dates. Column "edt" </td></tr>
    <tr><td class="paramname">NedFxg</td><td>(out) If a fixing date exist (1) or not (0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 27/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 13/Dec/2007: Avoid compilation warnings</li>
<li>Jon BARRUTIA - 28/Dec/2007: Remove all future dates</li>
<li>Jon BARRUTIA - 09/Jan/2008: Remove code in comments</li>
<li>Jon BARRUTIA - 21/Jan/2008: Call to lcMCIfxgGetFxgLstDat instead of MCIfxgGetLstDat. Remove the AllFxg argument, it is not needed.</li>
<li>Jon BARRUTIA - 29/Jan/2008: Fixing date added as argument. A list with fixing dates of each condition is added in the fixing data list.</li>
<li>Jon BARRUTIA - 30/Jan/2008: It does not need the Lin argument</li>
<li>Jon BARRUTIA - 31/Jan/2008: Only last fixing dates are set into each condition lines</li>
<li>Jon BARRUTIA - 14/Feb/2008: Set LdPurFxd to purge incorrect fixings</li>
<li>Jon BARRUTIA - 29/Feb/2008: For not OnDat components, dates list will contain only the component fixing date</li>
<li>Jon BARRUTIA - 10/Jul/2008: New argument to MCIinsGetAssCndCur</li>
<li>Jon BARRUTIA - 17/Dec/2008: Added a new argument to manage it all dates will be returned</li>
<li>Jon BARRUTIA - 23/Feb/2009: Treat the "user" frequency (adding LlTim, Tdt arguments)</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="a46ffb949347b3857b8500c979fabefac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgGetFxgDat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Mci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Frq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Shl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Pfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LlMciCcy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Mdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>FxgDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LlTim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Tdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>All</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last fixing date of a condition period. </p>
<p>Returns the last fixing date of a condition period</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mci</td><td>Monte Carlo instrument code </td></tr>
    <tr><td class="paramname">Beg</td><td>Begin date of the condition period </td></tr>
    <tr><td class="paramname">End</td><td>End date of the condition period </td></tr>
    <tr><td class="paramname">Dat</td><td>Calculation date </td></tr>
    <tr><td class="paramname">Frq</td><td>Frequency of the condition period </td></tr>
    <tr><td class="paramname">Shl</td><td>Irregular periods are short or long </td></tr>
    <tr><td class="paramname">Adj</td><td>If the dates must be adjusted or not. Possible values: </td></tr>
    <tr><td class="paramname">-</td><td>"No" the dates are not adjusted </td></tr>
    <tr><td class="paramname">-</td><td>"Yes" the dates are adjusted </td></tr>
    <tr><td class="paramname">Pfl</td><td>Adjustment method </td></tr>
    <tr><td class="paramname">Dev</td><td>Currency </td></tr>
    <tr><td class="paramname">LlMciCcy</td><td>List with the information of each instrument and all the currencies associted to them. This list must be recovered with MCIinsGetAssCndCur function </td></tr>
    <tr><td class="paramname">Mdb</td><td>Flag (Y/N) that indicates if dates must be modified in block if it is necessary, this is, if for calculating the open dates all the currencies of the instrument (stored in LlMciCcy) must be taken into account or only the currency given by parameter. If this flag is "N", the list LlMciCcy can be NULL </td></tr>
    <tr><td class="paramname">FxgDat</td><td>(out). Fixing date. It will be a reserved variable (CDA_TYPE) </td></tr>
    <tr><td class="paramname">LlTim</td><td>Time data list </td></tr>
    <tr><td class="paramname">Tdt</td><td>Time variable </td></tr>
    <tr><td class="paramname">All</td><td>Get all fixing dates (1) or only those to be treated (0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jordi CAMARASA 28/Aug/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 02/Oct/2007: Extracted from MCIfxgChkVal</li>
<li>Josune BIKUNA - 13/Nov/2007: take into account the flag 'Mdb' (modify dates in block) of the instrument for calculating the fixing open dates.</li>
<li>Jon BARRUTIA - 22/Jan/2008: Call to lcMCIfxgGetFxgLstDat to recover the fixing dates</li>
<li>Jon BARRUTIA - 17/Dec/2008: lcMCIfxgGetFxgLstDat has a new argument</li>
<li>Jon BARRUTIA - 23/Feb/2009: Treat "user" frequency (adding LlTim, Tdt arguments)</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="aa9bb0a3e8a251411f3e8a923a425f1e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgGetFxgLstDat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Mci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Frq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Shl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Pfl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LlMciCcy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Mdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>All</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LLTim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Tdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdDat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fixing dates list of a condition period. </p>
<p>Returns the fixing dates list of a condition period. It gets lists of dates between beginning and final dates:</p>
<ul>
<li>adjusting all dates that are closed</li>
<li>adjusting dates that are weekend without taking into account the closed dates It concats both lists, eliminates the duplicates dates and sorts by the date.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mci</td><td>Monte Carlo instrument code </td></tr>
    <tr><td class="paramname">Beg</td><td>Begin date of the condition period </td></tr>
    <tr><td class="paramname">End</td><td>End date of the condition period </td></tr>
    <tr><td class="paramname">Dat</td><td>Calculation date </td></tr>
    <tr><td class="paramname">Frq</td><td>Frequency of the condition period </td></tr>
    <tr><td class="paramname">Shl</td><td>Irregular periods are short or long </td></tr>
    <tr><td class="paramname">Adj</td><td>If the dates must be adjusted or not. Possible values: </td></tr>
    <tr><td class="paramname">-</td><td>"No" the dates are not adjusted </td></tr>
    <tr><td class="paramname">-</td><td>"Yes" the dates are adjusted </td></tr>
    <tr><td class="paramname">Pfl</td><td>Adjustment method </td></tr>
    <tr><td class="paramname">Dev</td><td>Currency </td></tr>
    <tr><td class="paramname">LlMciCcy</td><td>List with the information of each instrument and all the currencies associted to them. This list must be recovered with MCIinsGetAssCndCur function </td></tr>
    <tr><td class="paramname">Mdb</td><td>Flag (Y/N) that indicates if dates must be modified in block if it is necessary, this is, if for calculating the open dates all the currencies of the instrument (stored in LlMciCcy) must be taken into account or only the currency given by parameter. If this flag is "N", the list LlMciCcy can be NULL </td></tr>
    <tr><td class="paramname">All</td><td>Get all fixing dates (1) or only those to be treated (0) </td></tr>
    <tr><td class="paramname">LLTim</td><td>Time dependent tables dates list. Used for "user" frequency </td></tr>
    <tr><td class="paramname">Tdt</td><td>Time table name </td></tr>
    <tr><td class="paramname">LdDat</td><td>(out). Fixing dates list. NULL if no dates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 17/Jan/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 18/Nov/2008: Exit if any warning</li>
<li>Jon BARRUTIA - 17/Dec/2008: Added a new argument to manage it all dates will be returned</li>
<li>Jon BARRUTIA - 23/Feb/2009: Treat the "user" frequency (adding LlTim, Tdt arguments)</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="a7410d3a4d9d72a2f6eeb0db45544437c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgGetMci </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntMci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>All</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complete with the initial values for a deal in a given date. </p>
<p>Complete with the fixed initial values for a deal in a given date from one book. The future conditions are deleted if not all the fixing dates are asked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of alias </td></tr>
    <tr><td class="paramname">LdMciObj</td><td>Instrument's data list </td></tr>
    <tr><td class="paramname">CntMci</td><td>Index of the line treated into the LdMciObj list </td></tr>
    <tr><td class="paramname">Dat</td><td>Fixing date </td></tr>
    <tr><td class="paramname">All</td><td>Get all fixing dates (1) or only those to be treated (0) </td></tr>
    <tr><td class="paramname">LdVal</td><td>(OUT) Value's list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 16/Dec/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 19/Dec/2008: Do not remove future conditions if All = 1</li>
<li>Jon BARRUTIA - 27/Jan/2009: Generate LdVal schema also if there is not any condition</li>
<li>Jon BARRUTIA - 28/Jan/2009: lcMCIfxgSetCmpTyp &ndash;&gt; MCIinsSetCmpTyp</li>
<li>Jose M. NUNEZ - 23/Mar/2009: Read WeiPvb (new option to set the weight as parameter).</li>
<li>Nerea RAMOS - 20/Jan/2012: Do not get LdTdt because it is not used to avoid warnigns</li>
<li>Jon BARRUTIA - 02/Jul/2012: Compilation warning</li>
<li>Ruben GIL - 05/Apr/2013: Use size_t in DYNajoutexCol </li>
</ul>

</div>
</div>
<a class="anchor" id="a48d044fa3c4f9e535101edddc8a1109b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgGetMkt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Pro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdUmc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdAll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get market data value for the treated UMC and for the treated dates. </p>
<p>Get market data value for the treated UMC and for the treated dates. It also returns the fixing rates. It returns a list with the following columns:</p>
<ul>
<li>"edt": Date of the market datum</li>
<li>"umc": User market data code</li>
<li>"als": Database alias</li>
<li>"npa": Ticket number</li>
<li>"cmp": Subcomponent of the condition</li>
<li>"num": Deal number</li>
<li>"val": Market price</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">Pro</td><td>Profile to recover the market data </td></tr>
    <tr><td class="paramname">LdUmc</td><td>List with the treated UMC </td></tr>
    <tr><td class="paramname">LdDat</td><td>List with the treated dates. It should be sorted by umc and dat. </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">Off</td><td>Is launched from an official treatment (1) or not (0) </td></tr>
    <tr><td class="paramname">LdAll</td><td>(Out). List with the market data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 15/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 21/Nov/2007: Do not return the "dat" column. The date is already in "edt"</li>
<li>Jon BARRUTIA - 07/Dec/2007: Call to MKTgetHisUmc</li>
<li>Jon BARRUTIA - 07/Dec/2007: Take also the fixing rates</li>
<li>Jon BARRUTIA - 07/Dec/2007: Get fixing rates only for the treated dates</li>
<li>Gema ACHA - 09/Jan/2008: The fixing rates for FEA-ST will be in one pert cent.</li>
<li>Jon BARRUTIA - 14/Feb/2008: When calling the fixing from a not official treatment (as the pricer of the deal entry), recover current market data from mkt_dta instead of recovering them from the historic market data table.</li>
<li>Ruben GIL - 05/Apr/2013: Use size_t in DYNajoutexCol </li>
</ul>

</div>
</div>
<a class="anchor" id="a36b1d0a6b6f775bbc2001923c5c91d8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgGetMktCmp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdAll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get market data value for the treated UMC and for the treated dates. </p>
<p>Get market data value for the treated UMC and for the treated dates. It returns a list with the following columns:</p>
<ul>
<li>"edt": Date of the market datum</li>
<li>"cmp": Subcomponent of the condition</li>
<li>"TcNpa": Ticket number</li>
<li>"TcNum": Deal number</li>
<li>"als": Database alias</li>
<li>"VecEle": Code of the vector's element</li>
<li>"val": Market price</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of alias </td></tr>
    <tr><td class="paramname">LdDat</td><td>List with the treated dates. It should be sorted by umc and dat. </td></tr>
    <tr><td class="paramname">LdFxg</td><td>List with the component data </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">LdAll</td><td>(Out). List with the initial values of the components</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 15/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 20/Nov/2007. Remove added column (mrk) from LdDat.</li>
<li>Jon BARRUTIA - 20/Nov/2007. Take fixed initial values with condition codes instead of asset components</li>
<li>Jon BARRUTIA - 21/Nov/2007. Recover "edt" column instead of "dat"</li>
<li>Jon BARRUTIA - 21/Nov/2007. Conditions join with initial values only if exist</li>
<li>Jon BARRUTIA - 17/Dec/2007. Return the "VecEle" column</li>
<li>Jon BARRUTIA - 27/Dec/2007. "OnDat" management: It returns data for components that are not on date. Take into account the VecEle column</li>
<li>Jon BARRUTIA - 15/Jan/2008: Do not take market data for the fixing date, except for the constants</li>
<li>Jon BARRUTIA - 29/Jan/2008: Select only the already fixed initial values for the maximum date. Do not take fixing data for the treated fixing date. For conditions, take data only for its fixing dates.</li>
<li>Jon BARRUTIA - 11/Feb/2008: Get market data correctly for calculating the average of a component.</li>
<li>Jon BARRUTIA - 13/Feb/2008: Corrected when there is not any value</li>
<li>Jon BARRUTIA - 05/May/2008: Call to DBloadMultiDynIn to get initial values</li>
<li>Josune BIKUNA - 22/Oct/2008: Use CLINT type instead of int in cardinal functions</li>
<li>Jon BARRUTIA - 21/Nov/2008: Use &lt;&gt; instead of !=</li>
<li>Ruben GIL - 05/Apr/2013: Use size_t in DYNajoutexCol </li>
</ul>

</div>
</div>
<a class="anchor" id="a9633cab20c6e63b74cdadc444493f96b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgGetUmcMkt </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Mkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdMktUmc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get market data lines for the treated condition. </p>
<p>Get market data lines for the treated condition</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdMkt</td><td>List with the market data </td></tr>
    <tr><td class="paramname">LdFxg</td><td>List with the conditions to be fixed </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of the condition to be fixed </td></tr>
    <tr><td class="paramname">Mkt</td><td>1: get market data; 0: get components; 2: constants </td></tr>
    <tr><td class="paramname">LdMktUmc</td><td>(out) List with the market data for the treated condition. NULL if empty</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 16/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 20/Nov/2007: Added Mkt parameter</li>
<li>Jon BARRUTIA - 26/Nov/2007: Call to lcMCIfxgGetAllFxgDat to get fixing dates of the component. In comments now.</li>
<li>Jon BARRUTIA - 18/Dec/2007: Treat vector elements</li>
<li>Jon BARRUTIA - 22/Jan/2008: Correct when the component is not a vector. Remove 'mrk' column also from the result list. Remove the returned list if empty. lcMCIfxgGetAllFxgDat does not need the AllFxg argument</li>
<li>Jon BARRUTIA - 30/Jan/2008: Remove code in comments. Ctx is not needed.</li>
<li>Jon BARRUTIA - 28/Feb/2008: Return market data only for the treated dates </li>
</ul>

</div>
</div>
<a class="anchor" id="af5d0c364e4eaae7cfce490816ff022d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgIniVec </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise the fixing data list taking into account vectors. </p>
<p>Initialise the fixing data list taking into account vectors. It adds a column called "VecEle" to the input data list and sets there the code of each vector element. This code is formed by the "Ele" string and a correlative number for each sub-component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Fixing data list. "VecEle" column will be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 04/Dec/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 06/Dec/2007: Error message from DAT file</li>
<li>Jon BARRUTIA - 26/Dec/2007: Use the ticket number when setting the vector elements code</li>
<li>Jon BARRUTIA - 16/Jan/2008: Set as not valid when is empty the attribute that indicates if the component is a vector. Use MSG_LEN for the error message size.</li>
<li>Jon BARRUTIA - 12/Feb/2008: Remove not used variables: LdDat.</li>
<li>Jon BARRUTIA - 22/Feb/2008: Use DYNgbGetValid if there is anything in CmpVec </li>
</ul>

</div>
</div>
<a class="anchor" id="a513eb7e20a4a5a5e3314b259067e52a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgIsCal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ToFix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if a component is calculable or not. </p>
<p>Verify if a component is calculable or not depending on its sub-components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Data list </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of the treated component </td></tr>
    <tr><td class="paramname">ToFix</td><td>(out). Component is calculable (1) or not (0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 23/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 26/Nov/2007: verify taking into account the deal and instrument </li>
</ul>

</div>
</div>
<a class="anchor" id="a2ddafbae63e6da8613aa5eec1b58b847"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgIsToCal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>IsToCal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if there is any condition to fix. </p>
<p>Verify if there is any condition to fix. This is, components that have:</p>
<ul>
<li>an associated condition</li>
<li>the attribute "ToCal" marked as 1.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Fixing data list </td></tr>
    <tr><td class="paramname">IsToCal</td><td>(out). 1 if there is any condition to fix; 0 if not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 08/Jan/2008 </dd></dl>

</div>
</div>
<a class="anchor" id="acc6f9376d9179dc1564b516d0762d02d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgMrkKnwSbc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark as known all components that have it as subcomponent. </p>
<p>Mark as known all components that have it as subcomponent</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Fixing data list </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Line treated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 28/Mar/2008 </dd></dl>

</div>
</div>
<a class="anchor" id="a4432fca465540e66ec192c0aa4f31aeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgPur </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Pur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge of the incorrect fixed initial values. </p>
<p>Purge of the incorrect fixed initial values. For each deal-instrument-condition, and vector element if the condition is a vector, get the fixing dates previous to the current fixing date and remove the existent initial values for the dates that are not in this dates list. It takes into account that there can be different fixing dates for some subcomponent due to the currency. If a fixing date is closed for a currency, it takes the following one. So, the fixing dates will be different. A clause to be different of the fixing date is set because in case of a condition over component, the fixing dates list do not contain the current fixing date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdFxg</td><td>Fixing data list </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date </td></tr>
    <tr><td class="paramname">Pur</td><td>Purge incorrect fixed initial values (1) or not (0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 12/Feb/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 14/Feb/2008: Use LdPurFxd instead of LdFxd to purge incorrect fixings</li>
<li>Jon BARRUTIA - 28/Feb/2008: Correct the purge for sub-components with different dates</li>
<li>Jon BARRUTIA - 21/Nov/2008: Use &lt;&gt; instead of !=</li>
<li>Alex RODRIGUEZ - 05/Jul/2010: Use of DBexeDynIn to avoid execution errors. </li>
</ul>

</div>
</div>
<a class="anchor" id="aff7553f3b447c4aeb90f9cac9ff732e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSetAmoWeiStk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciPvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciTdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the amount, weight and strike values for each component. </p>
<p>Set the amount, weight and strike values for each component</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database connection </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of book alias for which the fixing is being done </td></tr>
    <tr><td class="paramname">LdDta</td><td>List with the information of the deal for which the fixing will be done </td></tr>
    <tr><td class="paramname">LdMciPvb</td><td>Variable parameters list. Otherwise, NULL. </td></tr>
    <tr><td class="paramname">LdMciTdt</td><td>Tdt list </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Josune BIKUNA - 10/Sep/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Josune BIKUNA - 10/Sep/2007: Set different default values for amount, weight and strike depending on the function to apply</li>
<li>Josune BIKUNA - 10/Sep/2007: Avoid compilation warnings when calling to lcMCIfxgFndPvb</li>
<li>Jon BARRUTIA - 21/Nov/2007: Treat also: MCI_PAY_OFF_CMP_TYP_SUM, MCI_PAY_OFF_CMP_TYP_MAX MCI_PAY_OFF_CMP_TYP_MIN, MCI_PAY_OFF_CMP_TYP_CTE</li>
<li>Jon BARRUTIA - 23/Nov/2007: Extracted from lcMCIfxgAplSubCmpFun</li>
<li>Jon BARRUTIA - 23/Nov/2007: Modified default values for the different functions.</li>
<li>Jon BARRUTIA - 28/Nov/2007: Take variable parameters only once</li>
<li>Jon BARRUTIA - 08/Jan/2008: Add and use the variable parameters when calling the function with dta in memory (deal entry)</li>
<li>Jon BARRUTIA - 29/Jan/2008: Initialise to minimum double value the weight and strike for comparaisons functions.</li>
<li>Jon BARRUTIA - 05/Feb/2008: Treat the time dependent tables. Fixing date added.</li>
<li>Jon BARRUTIA - 27/Feb/2008: Add treatment for MCI_PAY_OFF_CMP_TYP_VRN</li>
<li>Jon BARRUTIA - 30/Apr/2008: Correct the minimum double value for comparaisons functions.</li>
<li>Gema ACHA - 16/May/2008: Add a new parameter: time dependent table list</li>
<li>Jose M. NUNEZ - 23/Mar/2009: Added a new parameter: WeiPvb.</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="adb7cfca5870fc285cc5fbc855feba33f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSetCndAsRes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the calculated value for a condition in the result list. </p>
<p>Set the calculated value for a condition in the result list. It takes the value from the 'New' column and creates a new 'LdRes' list. If the component is a vector or only has one sub-component, copy the condition result off each subcomponent</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Fixing data list </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Treated counter of the fixing data list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 15/Feb/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Ruben GIL - 05/Apr/2013: Use size_t in DYNajoutexCol </li>
</ul>

</div>
</div>
<a class="anchor" id="aa0a017ce8fe2bb580ca0141c412d6d70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSetCndDat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciPvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtains and adds to the list the begin/end condition dates. </p>
<p>Obtains and adds to the list the begin/end condition dates. The result list should have the following columns:</p>
<ul>
<li>"als": alias of the database</li>
<li>"TcNum": number of the deal</li>
<li>"FldCndBeg": field name where the begin date of the condition is saved</li>
<li>"FldCndEnd": field name where the end date of the condition is saved It has the possibility to use a variable parameters list passed as argument. Useful when estimating something that is not into the database (like pricer).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdMciPvb</td><td>Variable parameters list. Otherwise, NULL. </td></tr>
    <tr><td class="paramname">LdRes</td><td>(in/out). Results list. It adds two columns: CndBeg, CndEnd </td></tr>
    <tr><td class="paramname">LdAls</td><td>Alias list to get the variable parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 06/Sep/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Ramon MARTINEZ - 06/Sep/2007: Bug, same varaible CndDat for Beg and Edt</li>
<li>Josune BIKUNA - 07/Sep/2007: Use lcMCIfxgFndPvbStr function to get the value of begin/end variable parameters. They will be first search in the explicitely configured values and then in the data list. This last action is necessary in case tc_dva/tc_clo values have been configured</li>
<li>Josune BIKUNA - 10/Sep/2007: The function lcMCIfxgFndPvb has been adapted for any data type</li>
<li>Jon BARRUTIA - 05/Oct/2007: Possibility to pass the variable parameters by argument</li>
<li>Jon BARRUTIA - 16/Nov/2007: Add the tc_dva, tc_clo as variable parameters when they do not come by argument</li>
<li>Jon BARRUTIA - 24/Nov/2007: Add the instrument code and ticket number to the error message</li>
<li>Jon BARRUTIA - 22/Oct/2008: tc_dva is substituted by ":ValDate" (MCI_PVBDEF_DVA). tc_clo is substituted by ":CloDate" (MCI_PVBDEF_CLO).</li>
<li>Basilio TAMAYO - 19/Sep/2012: DYNaddColumns and DYNajoutexCol must have size with type size_t </li>
</ul>

</div>
</div>
<a class="anchor" id="a4813b05f742d3c81324eb43e93847ac4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSetEquPof </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert equivalent payoff functions. E.g.: stop -&gt; if. </p>
<p>It does a conversion between some payoff functions when they are similar for the fixing treatment. The conversion that it do are:</p>
<ul>
<li>stop &ndash;&gt; if</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Fixing data list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 12/Feb/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 18/Feb/2008: Compilation warning </li>
</ul>

</div>
</div>
<a class="anchor" id="a2ba7b43fb5b082eb2785108705be4f35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSetPvbCmpTyp </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdPvb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the variable parameter for the component type. </p>
<p>Sets the variable parameter for the component type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdPvb</td><td>Variable parameter list </td></tr>
    <tr><td class="paramname">LdDta</td><td>Data list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 26/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 28/Jul/2008: Set in MciParCmpTyp column</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="a6fb48fd7d85aa0fb48602a561b95542f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSetSbcToCal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark component and all its subcomponents that will be calculated. </p>
<p>Mark component and all its subcomponents that will be calculated from a specific component. Recursive function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Data list </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of treated component</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 27/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 28/Nov/2007. It marks the calling component and all its subcomponents</li>
<li>Jon BARRUTIA - 26/Dec/2007: Verify if the subcomponent line exists before calling to its calculation</li>
<li>Jon BARRUTIA - 26/Dec/2007: Manage the "OnDat" attribute </li>
</ul>

</div>
</div>
<a class="anchor" id="a577385bb358fb18c79263a2b02a1e0a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSetToCal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the components that will be calculated. </p>
<p>Mark the components that will be calculated. The components that follow next points are used marked as calculables:</p>
<ul>
<li>Components that have a condition and it will be fixed to pass to FEA calculations</li>
<li>Components that have a valid condition and are on date</li>
<li>Components that are constants</li>
<li>Components that have defined a 'tprior' function and have defined any subcomponent But only the components with conditions are used to see if they are used as subcomponents.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Data list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 27/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 28/Nov/2007: Do not mark as calculable the component. Is done into the recursive function. It is called also for the constants.</li>
<li>Jon BARRUTIA - 19/Dec/2007: Treat also the OnDat column</li>
<li>Jon BARRUTIA - 04/Feb/2008: Treat the tprior payoff function</li>
<li>Jon BARRUTIA - 11/Feb/2008: Set ToCal to 1 when tprior but only if its subcomponent is treated into the list.</li>
<li>Jon BARRUTIA - 25/Mar/2008: Set as not calculable the conditions that are not to fix </li>
</ul>

</div>
</div>
<a class="anchor" id="a4504e95a8405826dd7fdfc314812cd23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgSolTpr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Fxd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the 'tprior' function. </p>
<p>Solve the 'tprior' function. It runs similar to the conditions. As the tprior function can be solved without any other components, they are solved before launching the calculations. The result is set into the 'LdFunDta' and 'LdRes' columns. Also, it marks as Knw the component and those components where it is used as subcomponent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>Alias list where the initial values will be recovered </td></tr>
    <tr><td class="paramname">LdFxg</td><td>Fixing data list </td></tr>
    <tr><td class="paramname">Fxd</td><td>Fixing date</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 01/Feb/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 07/Feb/2008: Error management when a subcomponent is not found. It can be possible if the conditions dates are not coherent.</li>
<li>Jon BARRUTIA - 11/Feb/2008: Treat only those tpriors that have ToCal as 1.</li>
<li>Jon BARRUTIA - 10/Mar/2008: Rename 'dat' column as 'edt'</li>
<li>Jon BARRUTIA - 28/Mar/2008: Set results into 'LdRes' and mark as Knw the component and those components where it is used as subcomponent</li>
<li>Jon BARRUTIA - 27/May/2008: Free memory</li>
<li>Jon BARRUTIA - 10/Jul/2008: New argument to MCIinsGetAssCndCur</li>
<li>Jon BARRUTIA - 18/Nov/2008: Control warnings after call to lcMCIfxgGetFxgLstDat</li>
<li>Jon BARRUTIA - 19/Nov/2008: Correct when no dates are recovered. Sort lists liberation.</li>
<li>Jon BARRUTIA - 20/Nov/2008: Compilation warnings</li>
<li>Jon BARRUTIA - 21/Nov/2008: Use &lt;&gt; instead of !=</li>
<li>Jon BARRUTIA - 17/Dec/2008: lcMCIfxgGetFxgLstDat has a new argument</li>
<li>Jon BARRUTIA - 23/Feb/2009: lcMCIfxgGetAllFxgDat needs new arguments for the "user" frequency. They are initialised to NULL.</li>
</ul>
<dl class="section user"><dt>Improve</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 23/Feb/2009: Correct the use of the "user" frequency. Correct the values of the LlTim, Tdt variables</li>
<li>Ruben GIL - 05/Apr/2013: Use size_t in DYNajoutexCol </li>
</ul>

</div>
</div>
<a class="anchor" id="a99d0369a199f612dda3b93224898d086"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgTypIsFxg </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Typ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Fix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if a payoff condition type should be fixed or not. </p>
<p>Returns if a payoff condition type should be fixed or not. The payoff conditions that do not require initial values are:</p>
<ul>
<li>MCI_POC_ARR: arrears</li>
<li>MCI_POC_EXE: exercise</li>
<li>MCI_POC_HLC: holdercancel</li>
<li>MCI_POC_ISC: issuercancel</li>
<li>MCI_POC_LTF: link2fut</li>
<li>MCI_POC_MSK: mask</li>
<li>MCI_POC_RST: reset</li>
<li>MCI_POC_VEC: vec</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Typ</td><td>Payoff condition type </td></tr>
    <tr><td class="paramname">Fix</td><td>(out). 1: It should be fixed; 0: if not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 09/Nov/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 06/Dec/2007: Added MCI_POC_VEC</li>
<li>Jon BARRUTIA - 20/Feb/2007: Added MCI_POC_RET. MCI_POC_VEC does not require an initialization. Set the condition types that do not require an initialization instead of those that require it (Josh Gray - FEA; 20/Feb/2008). </li>
</ul>

</div>
</div>
<a class="anchor" id="af6bc45dbebe970df645ce8a529290bf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int lcMCIfxgVecHasDifFxd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>DifFxd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify if there is any vector element with different fixing date. </p>
<p>It verifies if all elements of the vector have the same fixing date. It does not verify that the treated component is a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdFxg</td><td>Fixing data list </td></tr>
    <tr><td class="paramname">CntFxg</td><td>Index of the treated vector </td></tr>
    <tr><td class="paramname">DifFxd</td><td>(out). 1 if there is any vector element on date and other no; 0 if all vector elements have the same fixing date.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 18/Jan/2008 </dd></dl>

</div>
</div>
<a class="anchor" id="a7f81526de1d59ca5bf97b5b770201a7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgChkVal </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMci</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the operation is fixed for a date. </p>
<p>Checks if the operation is fixed for a date</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LdMci</td><td>MC instrument data list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jordi CAMARASA 28/Aug/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Ismael SERRANO - 29/Aug/2007: Call to MCIinsGetAssCur, MCIinsGetLegDta</li>
<li>Jordi CAMARASA - 31/Aug/2007: Fix some problems and fit code to almis rules</li>
<li>Jon BARRUTIA - 06/Sep/2007: ERR_FXG &ndash;&gt; MCI_TRT</li>
<li>Ramon MARTINEZ - 06/Sep/2007: Not delete lines after MCIfxgGetLstDat because they are deleted in the functions</li>
<li>Josune BIKUNA - 07/Sep/2007: Use lcMCIfxgFndPvbStr function to get the value of begin/end variable parameters. They will be first search in the explicitely configured values and then in the data list. This last action is necessary in case tc_dva/tc_clo values have been configured</li>
<li>Josune BIKUNA - 10/Sep/2007: The function lcMCIfxgFndPvb has been adapted for any data type</li>
<li>Josune BIKUNA - 10/Sep/2007: Correct the error getting the date for which if the fixing is done must be controlled. Get the last date of the list of dates instead of the first one</li>
<li>Josune BIKUNA - 10/Sep/2007: When recovering the fixing value use 'Val' instead of 'NewVal'</li>
<li>Josune BIKUNA - 25/Sep/2007: Add Adj, AdjScp and AddDat parameters when calling to MCIfxgGetLstDat function.</li>
<li>Josune BIKUNA - 25/Sep/2007: When checking if the fixing is done or not, get also the list of dates adjusting only the weekends</li>
<li>Jon BARRUTIA - 02/Oct/2007: All instrument information comes into the instrument data list</li>
<li>Jon BARRUTIA - 08/Oct/2007: Do not check the existence of the initial values for the "exercise" type conditions. Added the condition code to the warning message.</li>
<li>Jon BARRUTIA - 10/Oct/2007: If not fixing date, nothing to fix because the period begin in the future</li>
<li>Jon BARRUTIA - 08/Nov/2007: Use MCI_POC_EXE instead of the hard coded text</li>
<li>Jon BARRUTIA - 09/Nov/2007: Call to lcMCIfxgTypIsFxg to know if a condition needs initial values</li>
<li>Jon BARRUTIA - 06/Dec/2007: Take into account vector elements</li>
<li>Jon BARRUTIA - 22/Jan/2007: MSG_LEN used. snprintf used instead of sprintf.</li>
<li>Jon BARRUTIA - 11/Feb/2008: Use macrodefinitions for size of some columns</li>
<li>Jon BARRUTIA - 12/May/2008: Verify if there are conditions to fix before doing some treatments </li>
</ul>

</div>
</div>
<a class="anchor" id="a604c3348eacac8e84708bf0db2e23319"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgCnf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>FxgDat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Confirm inital values for selected instruments. </p>
<p>Confirm all the initial values realated to some intruments in a given date</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database connexion </td></tr>
    <tr><td class="paramname">LdDta</td><td>Data list </td></tr>
    <tr><td class="paramname">FxgDat</td><td>Date</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ismael SERRANO - 28/Jun/2007:</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 30/Aug/2007: Taken from EMCIfxgCnf</li>
<li>Jon BARRUTIA - 05/Sep/2007: Call to lcMCIfxgCnf</li>
<li>Josune BIKUNA - 07/Sep/2007: In the data list, the 'als' column must be in the first position, so move it if it is not</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings </li>
</ul>

</div>
</div>
<a class="anchor" id="ada99b15a7384c52b9c8f03aed70d5409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgDat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CalFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntMci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the initial values for a deal in a given date. </p>
<p>Get the fixed initial values for a deal in a given date from one book. It recalculates them if it is needed and the "CalFxg" argument is passed as "1".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdMciObj</td><td>Instrument's data list </td></tr>
    <tr><td class="paramname">CalFxg</td><td>Flag to indicate if the fixing should be calculated (1) or not (0) when no fixed initial values exist. </td></tr>
    <tr><td class="paramname">CntMci</td><td>Index of the line treated into the LdMciObj list </td></tr>
    <tr><td class="paramname">Dat</td><td>Fixing date </td></tr>
    <tr><td class="paramname">LdVal</td><td>(OUT) Value's list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ismael SERRANO - 03/Jul/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Ismael SERRANO - 30/jul/2007: Order by Dat</li>
<li>Jon BARRUTIA - 05/Sep/2007: OldVal, NewVal substitued by Val</li>
<li>Jon BARRUTIA - 05/Oct/2007: If no fixing data, calculate the fixing</li>
<li>Jon BARRUTIA - 05/Oct/2007: Corrected condition to exit without calculating the fixings</li>
<li>Jon BARRUTIA - 10/Oct/2007: Corrected when last condition is not fixed but exist other one previous</li>
<li>Jon BARRUTIA - 31/Oct/2007: Finds the asset to fix into the components list instead of taking it from the first line of the components list</li>
<li>Jon BARRUTIA - 08/Nov/2007: Do not fix the initial values for the "exercise" type conditions</li>
<li>Jon BARRUTIA - 08/Nov/2007: Use MCI_POC_EXE instead of the hard coded text</li>
<li>Jon BARRUTIA - 09/Nov/2007: Call to lcMCIfxgTypIsFxg to know if a condition needs initial values</li>
<li>Jon BARRUTIA - 12/Nov/2007: Correct initialisation of the index when searching the asset type components</li>
<li>Josune BIKUNA - 13/Nov/2007: Get also the instrument information 'Mdb' (modify dates in block) in the returned data list</li>
<li>Jon BARRUTIA - 13/Nov/2007: Fix also components</li>
<li>Jon BARRUTIA - 22/Nov/2007: Add the subcomponent column to the fixing data list</li>
<li>Jon BARRUTIA - 26/Nov/2007: Fix also already fixed initial values</li>
<li>Jon BARRUTIA - 26/Nov/2007: Correct the fixing list creation: one line per component-subcomponent instead of condition.</li>
<li>Jon BARRUTIA - 30/Nov/2007: MCIfxgFxg returns already only the conditions lines</li>
<li>Jon BARRUTIA - 05/Dec/2007: The already fixed initial values are taken into MCIfxgFxg when they should be recalculated.</li>
<li>Jon BARRUTIA - 06/Dec/2007: MCIfxgFxg has a new parameter to indicate if calculations must be launched</li>
<li>Jon BARRUTIA - 10/Dec/2007: MCIfxgFxg &ndash;&gt; MCIfxgFxgMci</li>
<li>Jon BARRUTIA - 11/Dec/2007: Correct type of CmpNum column</li>
<li>Jon BARRUTIA - 19/Dec/2007: Sort by subcomponent order</li>
<li>Jon BARRUTIA - 19/Dec/2007: VecEle returned also.</li>
<li>Jon BARRUTIA - 26/Dec/2007: Copy 'val' into 'new' when it has anything valid</li>
<li>Jon BARRUTIA - 27/Dec/2007: New column 'OnDat' to specify if the component should be fixed into the calculation date 'Dat'. Initialised to 1.</li>
<li>Jon BARRUTIA - 08/Jan/2008: MCIfxgFxgMci &ndash;&gt; lcMCIfxgFxgMci</li>
<li>Jon BARRUTIA - 09/Jan/2008: lcMCIfxgFxgMci has a new parameter: fixing date</li>
<li>Jon BARRUTIA - 15/Jan/2008: Added the asset code</li>
<li>Jon BARRUTIA - 30/Jan/2008: Copy 'Val' into 'New only if this one is not valid. Only distinct data are returned.</li>
<li>Jon BARRUTIA - 05/Feb/2008: Added the 'IntCod', 'AmoTim', 'WeiTim', 'StkTim' columns to treat the time dependent tables into the fixing. Set correctly the OnDat attribute.</li>
<li>Jon BARRUTIA - 08/Feb/2008: Added the 'MciCod' to the returned list</li>
<li>Jon BARRUTIA - 11/Feb/2008: Use macrodefinitions for size of some columns</li>
<li>Jon BARRUTIA - 13/Feb/2008: lcMCIfxgFxgMci has a new parameter: purging flag</li>
<li>Jon BARRUTIA - 26/Feb/2008: CmpNo added</li>
<li>Jon BARRUTIA - 28/Apr/2008: Remove value lines without valid value, it means that there is nothing fixed</li>
<li>Gema ACHA - 16/May/2008: lcMCIfxgFxgMci has a new parameter: time dependent table list</li>
<li>Jon BARRUTIA - 17/Dec/2008: Call to lcMCIfxgGetMci. Sort removing lists</li>
<li>Jon BARRUTIA - 19/Dec/2008: New argument calling to lcMCIfxgGetMci</li>
<li>Jon BARRUTIA - 26/Feb/2009: Sort correctly the already fixed initial values </li>
</ul>

</div>
</div>
<a class="anchor" id="a219e550a027e8e281d486d579694356d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgExeFxg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Pro</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the fixing of the components of MC instruments. </p>
<p>Executes the fixing of the components of MC instruments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">Dat</td><td>Calculation date </td></tr>
    <tr><td class="paramname">Pro</td><td>Profile</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 31/Aug/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 31/Aug/2007: Added AllFxg parameter to the call to MCIfxgFxg</li>
<li>Jon BARRUTIA - 04/Sep/2007: MCIfxgFxg is already called from MCIfxgRea</li>
<li>Jon BARRUTIA - 05/Sep/2007: MCIfxgRea does not return the MaxEle argument</li>
<li>Jon BARRUTIA - 24/Sep/2007: Comments</li>
<li>Jon BARRUTIA - 09/Nov/2007: Fix always the initial values </li>
</ul>

</div>
</div>
<a class="anchor" id="a29e22e69029c11af765c56d0598a4dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgGetFulMci </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMciObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>CntMci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all data of a MC instrument. </p>
<p>Returns a list with all data of a MC instrument. It returns all the fixing dates of each condition. Initial data is not fixed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdMciObj</td><td>Instrument's data list </td></tr>
    <tr><td class="paramname">CntMci</td><td>Index of the line treated into the LdMciObj list </td></tr>
    <tr><td class="paramname">Dat</td><td>Fixing date </td></tr>
    <tr><td class="paramname">LdVal</td><td>(OUT) Value's list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 16/Dec/2008</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 19/Dec/2008: New argument calling to lcMCIfxgGetMci</li>
<li>Jon BARRUTIA - 21/Jan/2009: Sort resultant list also by fixing date </li>
</ul>

</div>
</div>
<a class="anchor" id="acb6cfa4f775740456c713e84259858b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgGetFxgNpaDat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdNpa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>FldNpa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdFxg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refresh function for blind options exercise/expiration: Cash. </p>
<p>Refresh function for blind options exercise/expiration: Cash</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database connection to a database where the fixings are saved </td></tr>
    <tr><td class="paramname">LdNpa</td><td>Deal data list </td></tr>
    <tr><td class="paramname">FldNpa</td><td>Name of the column of "LdNpa" where the deal identifier is saved </td></tr>
    <tr><td class="paramname">Dat</td><td>Fixing date </td></tr>
    <tr><td class="paramname">LdFxg</td><td>(out). Fixing data list. Returned columns: "Dat", "TcNpa", "MciCod", "CndCod", "Val"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 23/Jan/2009 </dd></dl>

</div>
</div>
<a class="anchor" id="a7d78e66045e4adf87c85452b4a870636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgGetLstDat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Mci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>DatIni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>DatFin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Frq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Shl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>AdjSco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>AdjMth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Ccy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LlMciCcy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Mdb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AddDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>All</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LLTim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Tdt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the list of dates to be fixed between 2 dates, previous or equal to another one. </p>
<p>Get the list of dates to be fixed between 2 dates, previous or equal to another one</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mci</td><td>Instrument code </td></tr>
    <tr><td class="paramname">DatIni</td><td>Initial date </td></tr>
    <tr><td class="paramname">DatFin</td><td>Final data </td></tr>
    <tr><td class="paramname">Dat</td><td>Reference date. The dates in the list will be previous or equal to this one </td></tr>
    <tr><td class="paramname">Frq</td><td>Frequency. The treated ones are: "d5", "w", "m", "cm", "ecm", "3m", "6m", "y", "user". </td></tr>
    <tr><td class="paramname">Shl</td><td>Irregular periods are short or long </td></tr>
    <tr><td class="paramname">Adj</td><td>If the dates must be adjusted or not. Possible values:<ul>
<li>"No" the dates are not adjusted</li>
<li>"Yes" the dates are adjusted </li>
</ul>
</td></tr>
    <tr><td class="paramname">AdjSco</td><td>Adjustment scope in case the adjustment is required. Possible values:<ul>
<li>"All" all the closed days are adjusted</li>
<li>"WekEnd" only weekend days are adjusted </li>
</ul>
</td></tr>
    <tr><td class="paramname">AdjMth</td><td>Adjustment method </td></tr>
    <tr><td class="paramname">Ccy</td><td>Currency </td></tr>
    <tr><td class="paramname">LlMciCcy</td><td>List with the information of each instrument and all the currencies associted to them. This list must be recovered with MCIinsGetAssCndCur function </td></tr>
    <tr><td class="paramname">Mdb</td><td>Flag (Y/N) that indicates if dates must be modified in block if it is necessary, this is, if for calculating the open dates all the currencies of the instrument (stored in LlMciCcy) must be taken into account or only the currency given by parameter. If this flag is "N", the list LlMciCcy can be NULL </td></tr>
    <tr><td class="paramname">AddDat</td><td>Flag indicating in the given date in 'Dat' parameter must be added in the returned list of dates in the first position if it is not in the list </td></tr>
    <tr><td class="paramname">All</td><td>Get all fixing dates (1) or only those to be treated (0) </td></tr>
    <tr><td class="paramname">LLTim</td><td>Time dependent tables dates list. Used for "user" frequency </td></tr>
    <tr><td class="paramname">Tdt</td><td>Time table name </td></tr>
    <tr><td class="paramname">LdVal</td><td>(OUT) Dates's list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ismael SERRANO - 16/Aug/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Ismael SERRANO - 22/Aug/2007: If DatIni == DatFin then return DatIni</li>
<li>Ramon MARTINEZ - 06/Sep/2007: Add parameter Dat</li>
<li>Josune BIKUNA - 25/Sep/2007: Add Adj parameter, this is, the flag indicating in the clsed dates must be adjusted or not. Add AdjScp (adjustment scope) parameter, this is, which are the date that must be adjusted in case it must be. See parameter description. Add AddDat parameter, this is, a flag indicating in the giving date in Dat parameter must be added also in the returned list of dates if it is not yet.</li>
<li>Ramon MARTINEZ - 09/Nov/2007: Change emc by ecm</li>
<li>Josune BIKUNA - 13/Nov/2007: Add parameters LlMciCcy, Mdb. They will allow to used all the currencies of an instrument for calculating open dates instead of onlt one currency. See parameters</li>
<li>Gema ACHA - 19/Nov/2007: Check that initial date is smaller than end date</li>
<li>Josune BIKUNA - 20/Nov/2007: Rename AdjScp -&gt; AdjSco</li>
<li>Gema ACHA - 20/Nov/2007: Add warning info in the date check</li>
<li>Jon BARRUTIA - 31/Jan/2008: Added 'Once a week' frequency</li>
<li>Jon BARRUTIA - 22/Jul/2008: Improve the message when the init - end dates are incorrect</li>
<li>Josune BIKUNA - 22/Oct/2008: Use CLINT type instead of int in cardinal functions</li>
<li>Jon BARRUTIA - 18/Nov/2008: Add the instrument code to the warning message if end &lt; ini</li>
<li>Jon BARRUTIA - 17/Dec/2008: Add the possibility to return all the fixing dates</li>
<li>Jon BARRUTIA - 23/Feb/2009: Treat the "user" frequency</li>
<li>Jon BARRUTIA - 13/Mar/2009: Corrected when no found user frequencies</li>
<li>Manuel SANMARTIN - 02/Feb/2009: Add the broken period and end of month ajusted flag</li>
<li>Alex RODRIGUEZ - 10/Sep/2010: Convert YesAll string to All</li>
<li>Basilio TAMAYO - 19/Sep/2012: DYNaddColumns and DYNajoutexCol must have size with type size_t</li>
<li>Lorea NAVARRO - 23/Oct/2012: Modifications in header to avoid Doxygen warnings</li>
<li>Ruben GIL - 05/Apr/2013: Use size_t in DYNajoutexCol </li>
</ul>

</div>
</div>
<a class="anchor" id="ae52eceba501c7a6105fc58ce7efb1d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgPurDea </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Purge the fixed initial values for inexistent deals. </p>
<p>Purge the fixed initial values for inexistent deals. These deals are maintained and the initial values for the rest are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">Dea</td><td>SQL sentence to select the existent stock to maintain their initial values. It is also possible to pass a string with the deal codes to use in a IN clause</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 12/Feb/2008 </dd></dl>

</div>
</div>
<a class="anchor" id="a2852385bfd62049c4cc5115484a7cb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgRea </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>AllFxg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>FxgDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Pro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>LdRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read inital values for selected instruments. </p>
<p>Read all the initial values related to some intruments in a given date. Depending on the "AllFxg" argument, it fixes also the fixed values or not. To know the dates to fix, it begins from the end date and comes back with the frequency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database connexion </td></tr>
    <tr><td class="paramname">LdAls</td><td>List of aliases where recover deals. One column called "als" </td></tr>
    <tr><td class="paramname">Fix</td><td>Fix the initial values (1) or only read the existent ones (0) </td></tr>
    <tr><td class="paramname">AllFxg</td><td>Fixing method: if the already fixed values must be fixed again (1) or not (0) </td></tr>
    <tr><td class="paramname">FxgDat</td><td>Calculation date </td></tr>
    <tr><td class="paramname">Pro</td><td>Profile to get the market data </td></tr>
    <tr><td class="paramname">LdMci</td><td>List with the MC instrument codes to recover </td></tr>
    <tr><td class="paramname">LdDev</td><td>List with the currencies to use as filter in the data selection </td></tr>
    <tr><td class="paramname">LdRes</td><td>(OUT) Result list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0: OK)</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ismael SERRANO - 21/Jun/2007:</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Ismael SERRANO - 30/Jul/2007: Save MaxEle in a criteria</li>
<li>Jordi CAMARASA - 21/Aug/2007: Remove lines wich are not into the margins of begin date and end date</li>
<li>Jon BARRUTIA - 30/Aug/2007: Taken from EMCIfxgCnf</li>
<li>Jon BARRUTIA - 31/Aug/2007: LdAls should have a column called "als"</li>
<li>Jon BARRUTIA - 03/Sep/2007: Treat AllFxg and Pro arguments</li>
<li>Jon BARRUTIA - 05/Sep/2007: OldVal, NewVal substitued by Val. MaxEle removed.</li>
<li>Jon BARRUTIA - 06/Sep/2007: Corrected recover of the ini and end condition dates</li>
<li>Ramon MARTINEZ - 06/Sep/2007: Add parameter FxgDat to MCIfxgGetLstDat</li>
<li>Josune BIKUNA - 10/Sep/2007: Get the information for each subcomponent</li>
<li>Josune BIKUNA - 10/Sep/2007: From now on, the function that carries out the fixing, receives a list of books as parameter</li>
<li>Josune BIKUNA - 25/Sep/2007: Add Adj, AdjScp and AddDat parameters when calling to MCIfxgGetLstDat function.</li>
<li>Josune BIKUNA - 25/Sep/2007: When recovering the data to fix, take into acount that the assets for which today is closed and they must be fixed on the next open day, must be also fixed today to avoid problems when calculating an instrument price for today. The fixing of those assets will be done again tomorrow with the correct prices.</li>
<li>Jon BARRUTIA - 05/Oct/2007: Call to lcMCIfxgSetCndDat, MCIfxgFxg modified</li>
<li>Jon BARRUTIA - 09/Nov/2007: Add the 'Fix' argument to know whether the initial values should be fixed or not.</li>
<li>Jon BARRUTIA - 12/Nov/2007: Recover also the AssCmp field of afuMciFxg</li>
<li>Josune BIKUNA - 13/Nov/2007: take into account the flag 'Mdb' (modify dates in block) of the instrument for calculating the fixing open dates.</li>
<li>Jon BARRUTIA - 14/Nov/2007: Use tc_deb instead of tc_dva in the where clause. Do not recover dates because they are not used.</li>
<li>Basilio TAMAYO - 16/Nov/2007: Deleted AmoCte, WeiCte and StkCte from table afuMciSubCmp</li>
<li>Jon BARRUTIA - 20/Nov/2007: Get also Dva,Clo and SubTyp, SubCmp. External join with the assets table because we can have a component (not defined into the assets table).</li>
<li>Jon BARRUTIA - 26/Nov/2007: Fixing of components</li>
<li>Jon BARRUTIA - 30/Nov/2007: Correct the list data construction when a component has multiple assets.</li>
<li>Jon BARRUTIA - 30/Nov/2007: MCIfxgFxg returns already only the conditions lines</li>
<li>Jon BARRUTIA - 04/Dec/2007: Correct the join with the variable parameters table</li>
<li>Jon BARRUTIA - 04/Dec/2007: Remove the vector element column if the component is not a vector</li>
<li>Jon BARRUTIA - 06/Dec/2007: MCIfxgFxg has a new parameter to indicate if calculations must be launched</li>
<li>Jon BARRUTIA - 10/Dec/2007: Call to MCIfxgFxg instead of MCIfxgFxg</li>
<li>Jon BARRUTIA - 10/Dec/2007: Sort instrument data by subcomponent order</li>
<li>Jon BARRUTIA - 11/Dec/2007: Correct crash when no data to fix</li>
<li>Jon BARRUTIA - 11/Dec/2007: Correct the order by clause when getting components data</li>
<li>Jon BARRUTIA - 20/Dec/2007: MCIfxgFxg &ndash;&gt; lcMCIfxgFxg</li>
<li>Jon BARRUTIA - 27/Dec/2007: Not remove conditions that are not on fixing date because they are needed or can be needed in some calculations.</li>
<li>Jon BARRUTIA - 27/Dec/2007: Fixing data not on fixing date</li>
<li>Jon BARRUTIA - 27/Dec/2007: Treat when no fixing date is found</li>
<li>Jon BARRUTIA - 27/Dec/2007: Use lcMCIfxgGetFxgDat to get a fixing date</li>
<li>Jon BARRUTIA - 30/Jan/2008: Sort correctly the resultant list</li>
<li>Jon BARRUTIA - 05/Feb/2008: Added the 'IntCod' column (used solving time dependent tables)</li>
<li>Jon BARRUTIA - 11/Feb/2008: Use macrodefinitions for size of some columns</li>
<li>Gema ACHA - 09/Apr/2008: Convert sentences with left/right joins to SQL-Ansi</li>
<li>Gema ACHA - 11/Apr/2008: Change join name</li>
<li>Jon BARRUTIA - 14/Apr/2008: Optimise the sentence selecting only the 'blind' deals.</li>
<li>Jon BARRUTIA - 14/May/2008: Limit the diffusion databases list depending on their type</li>
<li>Jon BARRUTIA - 27/May/2008: Take the instrument currency if the condition has not any</li>
<li>Jon BARRUTIA - 10/Jul/2008: Treat generic assets. New argument to MCIinsGetAssCndCur</li>
<li>Jon BARRUTIA - 29/Jul/2008: Generic assets. Show the asset code</li>
<li>Jon BARRUTIA - 19/Dec/2008: New argument for lcMCIfxgGetFxgDat</li>
<li>Jon BARRUTIA - 28/Jan/2009: lcMCIfxgSetCmpTyp &ndash;&gt; MCIinsSetCmpTyp</li>
<li>Jon BARRUTIA - 12/Feb/2009: Do not set anything into the AssCmp column if not a generic asset or vector</li>
<li>Jon BARRUTIA - 13/Feb/2009: Use the correct list of alias to get the variable parameters</li>
<li>Jon BARRUTIA - 23/Feb/2009: Treat the "user" frequency</li>
<li>Jon BARRUTIA - 13/Mar/2009: Get the time dependent tables from the trading books</li>
<li>Jose M. NUNEZ - 23/Mar/2009: Added WeiPvb (Variable parameter option for weight).</li>
<li>Ruben GIL - 05/Apr/2013: Use size_t in DYNajoutexCol </li>
</ul>

</div>
</div>
<a class="anchor" id="a4768e1a5b65f51a874716bf134a9c39f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCIfxgSetFxgDat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdAls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>LdMci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>Dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>All</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a column with the last fixing date. </p>
<p>Adds a column with the last fixing date into the payoff conditions data list. The new column name is: "FxgDat".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ctx</td><td>Database context </td></tr>
    <tr><td class="paramname">LdAls</td><td>Diffusion books list </td></tr>
    <tr><td class="paramname">LdMci</td><td>MC instruments data list </td></tr>
    <tr><td class="paramname">Dat</td><td>Calculation date </td></tr>
    <tr><td class="paramname">All</td><td>Get all fixing dates (1) or only those to be treated (0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code (0 if OK).</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jon BARRUTIA - 22/Oct/2007</dd></dl>
<dl class="section user"><dt>Modified</dt><dd></dd></dl>
<ul>
<li>Jon BARRUTIA - 10/Oct/2007: Set as invalid the fixing date when it does not exist (because it is future)</li>
<li>Josune BIKUNA - 13/Nov/2007: take into account the flag 'Mdb' (modify dates in block) of the instrument for calculating the fixing open dates.</li>
<li>Jon BARRUTIA - 10/Jul/2008: New argument to MCIinsGetAssCndCur</li>
<li>Jon BARRUTIA - 19/Dec/2008: New argument All</li>
<li>Jon BARRUTIA - 23/Feb/2009: Treat "user" frequency </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="mci_fxg_8c.html">mciFxg.c</a></li>
    <li class="footer">Copyright &#169 ALMIS Informatica Financiera S.L. Reserved all the rights. Generated on Wed Jul 4 2018 22:33:49 for AFU by 
    <a href="http://www.almis.com">
    <img class="footer" src="DxyAlm.png" alt="ALMIS"/></a> </li>
  </ul>
</div>
</body>
</html>
